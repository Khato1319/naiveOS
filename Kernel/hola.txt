
kernel.elf:     file format elf64-x86-64


Disassembly of section .text:

0000000000100000 <loader>:
  100000:	e8 41 17 00 00       	callq  101746 <initializeKernelBinary>
  100005:	48 89 c4             	mov    %rax,%rsp
  100008:	e8 75 18 00 00       	callq  101882 <main>

000000000010000d <hang>:
  10000d:	fa                   	cli    
  10000e:	f4                   	hlt    
  10000f:	eb fc                	jmp    10000d <hang>

0000000000100011 <memset>:
#include <stdint.h>

void * memset(void * destination, int32_t c, uint64_t length)
{
  100011:	55                   	push   %rbp
  100012:	48 89 e5             	mov    %rsp,%rbp
  100015:	48 83 ec 28          	sub    $0x28,%rsp
  100019:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  10001d:	89 75 e4             	mov    %esi,-0x1c(%rbp)
  100020:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	uint8_t chr = (uint8_t)c;
  100024:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  100027:	88 45 ff             	mov    %al,-0x1(%rbp)
	char * dst = (char*)destination;
  10002a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  10002e:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	while(length--)
  100032:	eb 11                	jmp    100045 <memset+0x34>
		dst[length] = chr;
  100034:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  100038:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  10003c:	48 01 c2             	add    %rax,%rdx
  10003f:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  100043:	88 02                	mov    %al,(%rdx)
	while(length--)
  100045:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  100049:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
  10004d:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  100051:	48 85 c0             	test   %rax,%rax
  100054:	75 de                	jne    100034 <memset+0x23>

	return destination;
  100056:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  10005a:	c9                   	leaveq 
  10005b:	c3                   	retq   

000000000010005c <memcpy>:

void * memcpy(void * destination, const void * source, uint64_t length)
{
  10005c:	55                   	push   %rbp
  10005d:	48 89 e5             	mov    %rsp,%rbp
  100060:	48 83 ec 48          	sub    $0x48,%rsp
  100064:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  100068:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  10006c:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
	* the compiler to be reasonably intelligent about optimizing
	* the divides and modulos out. Fortunately, it is.
	*/
	uint64_t i;

	if ((uint64_t)destination % sizeof(uint32_t) == 0 &&
  100070:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  100074:	83 e0 03             	and    $0x3,%eax
  100077:	48 85 c0             	test   %rax,%rax
  10007a:	75 71                	jne    1000ed <memcpy+0x91>
		(uint64_t)source % sizeof(uint32_t) == 0 &&
  10007c:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  100080:	83 e0 03             	and    $0x3,%eax
	if ((uint64_t)destination % sizeof(uint32_t) == 0 &&
  100083:	48 85 c0             	test   %rax,%rax
  100086:	75 65                	jne    1000ed <memcpy+0x91>
		length % sizeof(uint32_t) == 0)
  100088:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  10008c:	83 e0 03             	and    $0x3,%eax
		(uint64_t)source % sizeof(uint32_t) == 0 &&
  10008f:	48 85 c0             	test   %rax,%rax
  100092:	75 59                	jne    1000ed <memcpy+0x91>
	{
		uint32_t *d = (uint32_t *) destination;
  100094:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  100098:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
		const uint32_t *s = (const uint32_t *)source;
  10009c:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  1000a0:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

		for (i = 0; i < length / sizeof(uint32_t); i++)
  1000a4:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  1000ab:	00 
  1000ac:	eb 2f                	jmp    1000dd <memcpy+0x81>
			d[i] = s[i];
  1000ae:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  1000b2:	48 8d 14 85 00 00 00 	lea    0x0(,%rax,4),%rdx
  1000b9:	00 
  1000ba:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  1000be:	48 01 c2             	add    %rax,%rdx
  1000c1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  1000c5:	48 8d 0c 85 00 00 00 	lea    0x0(,%rax,4),%rcx
  1000cc:	00 
  1000cd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  1000d1:	48 01 c8             	add    %rcx,%rax
  1000d4:	8b 00                	mov    (%rax),%eax
  1000d6:	89 02                	mov    %eax,(%rdx)
		for (i = 0; i < length / sizeof(uint32_t); i++)
  1000d8:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  1000dd:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  1000e1:	48 c1 e8 02          	shr    $0x2,%rax
  1000e5:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  1000e9:	77 c3                	ja     1000ae <memcpy+0x52>
	{
  1000eb:	eb 44                	jmp    100131 <memcpy+0xd5>
	}
	else
	{
		uint8_t * d = (uint8_t*)destination;
  1000ed:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  1000f1:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
		const uint8_t * s = (const uint8_t*)source;
  1000f5:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  1000f9:	48 89 45 d8          	mov    %rax,-0x28(%rbp)

		for (i = 0; i < length; i++)
  1000fd:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  100104:	00 
  100105:	eb 20                	jmp    100127 <memcpy+0xcb>
			d[i] = s[i];
  100107:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  10010b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  10010f:	48 01 c2             	add    %rax,%rdx
  100112:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  100116:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  10011a:	48 01 c8             	add    %rcx,%rax
  10011d:	0f b6 00             	movzbl (%rax),%eax
  100120:	88 02                	mov    %al,(%rdx)
		for (i = 0; i < length; i++)
  100122:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  100127:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  10012b:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  10012f:	72 d6                	jb     100107 <memcpy+0xab>
	}

	return destination;
  100131:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
}
  100135:	c9                   	leaveq 
  100136:	c3                   	retq   

0000000000100137 <numToStr2>:
//      2. El buffer
// ----------------------------------------------------------
// Retorna: la longitud del numero 
// 			(incluyendo el - si es negativo)  
// ----------------------------------------------------------
int numToStr2(int num, char * str) {
  100137:	55                   	push   %rbp
  100138:	48 89 e5             	mov    %rsp,%rbp
  10013b:	48 83 ec 30          	sub    $0x30,%rsp
  10013f:	89 7d dc             	mov    %edi,-0x24(%rbp)
  100142:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	int neg=0;
  100146:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	if (num<0) {
  10014d:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  100151:	79 16                	jns    100169 <numToStr2+0x32>
		str[0]='-';
  100153:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  100157:	c6 00 2d             	movb   $0x2d,(%rax)
		str++;
  10015a:	48 83 45 d0 01       	addq   $0x1,-0x30(%rbp)
		num=num*(-1);
  10015f:	f7 5d dc             	negl   -0x24(%rbp)
		neg=1;
  100162:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%rbp)
	}	
	int i, rem, n, len = 0;
  100169:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%rbp)
	n = num;
  100170:	8b 45 dc             	mov    -0x24(%rbp),%eax
  100173:	89 45 f4             	mov    %eax,-0xc(%rbp)
	while (n != 0) {
  100176:	eb 1f                	jmp    100197 <numToStr2+0x60>
	  len++;
  100178:	83 45 f0 01          	addl   $0x1,-0x10(%rbp)
	  n /= 10;
  10017c:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  10017f:	ba 67 66 66 66       	mov    $0x66666667,%edx
  100184:	89 c8                	mov    %ecx,%eax
  100186:	f7 ea                	imul   %edx
  100188:	c1 fa 02             	sar    $0x2,%edx
  10018b:	89 c8                	mov    %ecx,%eax
  10018d:	c1 f8 1f             	sar    $0x1f,%eax
  100190:	29 c2                	sub    %eax,%edx
  100192:	89 d0                	mov    %edx,%eax
  100194:	89 45 f4             	mov    %eax,-0xc(%rbp)
	while (n != 0) {
  100197:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  10019b:	75 db                	jne    100178 <numToStr2+0x41>
	}
	for (i = 0; i < len; i++) {
  10019d:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
  1001a4:	eb 63                	jmp    100209 <numToStr2+0xd2>
	  rem = num % 10;
  1001a6:	8b 4d dc             	mov    -0x24(%rbp),%ecx
  1001a9:	ba 67 66 66 66       	mov    $0x66666667,%edx
  1001ae:	89 c8                	mov    %ecx,%eax
  1001b0:	f7 ea                	imul   %edx
  1001b2:	c1 fa 02             	sar    $0x2,%edx
  1001b5:	89 c8                	mov    %ecx,%eax
  1001b7:	c1 f8 1f             	sar    $0x1f,%eax
  1001ba:	29 c2                	sub    %eax,%edx
  1001bc:	89 d0                	mov    %edx,%eax
  1001be:	c1 e0 02             	shl    $0x2,%eax
  1001c1:	01 d0                	add    %edx,%eax
  1001c3:	01 c0                	add    %eax,%eax
  1001c5:	29 c1                	sub    %eax,%ecx
  1001c7:	89 c8                	mov    %ecx,%eax
  1001c9:	89 45 ec             	mov    %eax,-0x14(%rbp)
	  num = num / 10;
  1001cc:	8b 4d dc             	mov    -0x24(%rbp),%ecx
  1001cf:	ba 67 66 66 66       	mov    $0x66666667,%edx
  1001d4:	89 c8                	mov    %ecx,%eax
  1001d6:	f7 ea                	imul   %edx
  1001d8:	c1 fa 02             	sar    $0x2,%edx
  1001db:	89 c8                	mov    %ecx,%eax
  1001dd:	c1 f8 1f             	sar    $0x1f,%eax
  1001e0:	29 c2                	sub    %eax,%edx
  1001e2:	89 d0                	mov    %edx,%eax
  1001e4:	89 45 dc             	mov    %eax,-0x24(%rbp)
	  str[len - (i + 1)] = rem + '0';
  1001e7:	8b 45 f8             	mov    -0x8(%rbp),%eax
  1001ea:	f7 d0                	not    %eax
  1001ec:	89 c2                	mov    %eax,%edx
  1001ee:	8b 45 f0             	mov    -0x10(%rbp),%eax
  1001f1:	01 d0                	add    %edx,%eax
  1001f3:	48 63 d0             	movslq %eax,%rdx
  1001f6:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  1001fa:	48 01 d0             	add    %rdx,%rax
  1001fd:	8b 55 ec             	mov    -0x14(%rbp),%edx
  100200:	83 c2 30             	add    $0x30,%edx
  100203:	88 10                	mov    %dl,(%rax)
	for (i = 0; i < len; i++) {
  100205:	83 45 f8 01          	addl   $0x1,-0x8(%rbp)
  100209:	8b 45 f8             	mov    -0x8(%rbp),%eax
  10020c:	3b 45 f0             	cmp    -0x10(%rbp),%eax
  10020f:	7c 95                	jl     1001a6 <numToStr2+0x6f>
	}
	return len+neg;
  100211:	8b 55 f0             	mov    -0x10(%rbp),%edx
  100214:	8b 45 fc             	mov    -0x4(%rbp),%eax
  100217:	01 d0                	add    %edx,%eax
}
  100219:	c9                   	leaveq 
  10021a:	c3                   	retq   

000000000010021b <timer_handler>:

static unsigned long ticks = 0;
static unsigned long prevTicks = 0;
void (*routine)() = 0;

void timer_handler() {
  10021b:	55                   	push   %rbp
  10021c:	48 89 e5             	mov    %rsp,%rbp
	ticks++;
  10021f:	48 8b 05 e2 3d 00 00 	mov    0x3de2(%rip),%rax        # 104008 <ticks>
  100226:	48 83 c0 01          	add    $0x1,%rax
  10022a:	48 89 05 d7 3d 00 00 	mov    %rax,0x3dd7(%rip)        # 104008 <ticks>
	// 	routine();
	// 	setPointer(videoAux);
	// 	prevTicks = ticks;
	// }
		
}
  100231:	5d                   	pop    %rbp
  100232:	c3                   	retq   

0000000000100233 <set_routine>:

void set_routine(void (*f)()) {
  100233:	55                   	push   %rbp
  100234:	48 89 e5             	mov    %rsp,%rbp
  100237:	48 83 ec 08          	sub    $0x8,%rsp
  10023b:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	routine = f;
  10023f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  100243:	48 89 05 b6 3d 00 00 	mov    %rax,0x3db6(%rip)        # 104000 <routine>
}
  10024a:	c9                   	leaveq 
  10024b:	c3                   	retq   

000000000010024c <ticks_elapsed>:

int ticks_elapsed() {
  10024c:	55                   	push   %rbp
  10024d:	48 89 e5             	mov    %rsp,%rbp
	return ticks;
  100250:	48 8b 05 b1 3d 00 00 	mov    0x3db1(%rip),%rax        # 104008 <ticks>
}
  100257:	5d                   	pop    %rbp
  100258:	c3                   	retq   

0000000000100259 <seconds_elapsed>:

int seconds_elapsed() {
  100259:	55                   	push   %rbp
  10025a:	48 89 e5             	mov    %rsp,%rbp
	return ticks / 18;
  10025d:	48 8b 05 a4 3d 00 00 	mov    0x3da4(%rip),%rax        # 104008 <ticks>
  100264:	48 ba 8f e3 38 8e e3 	movabs $0xe38e38e38e38e38f,%rdx
  10026b:	38 8e e3 
  10026e:	48 f7 e2             	mul    %rdx
  100271:	48 89 d0             	mov    %rdx,%rax
  100274:	48 c1 e8 04          	shr    $0x4,%rax
}
  100278:	5d                   	pop    %rbp
  100279:	c3                   	retq   

000000000010027a <sysCallDispatcher>:
long timerTick(void (*f)());
void getDate(char * buf);

static SysCallR sysCalls[255] = {(SysCallR) &read, (SysCallR) &write, (SysCallR) &clear, (SysCallR) &splitScreen, (SysCallR) &changeScreen, (SysCallR)&getChar,(SysCallR)&ncClearLine,(SysCallR)&getTime, (SysCallR)&timerTick, (SysCallR)&set_kb_target, (SysCallR)&getDate}; // = {(SysCall) &read, (SysCall) &write, ...} //cpuid, reg_info, mem_dump, clock

uint64_t sysCallDispatcher(uint64_t rdi, uint64_t rsi, uint64_t rdx, uint64_t rcx, uint64_t rax) {
  10027a:	55                   	push   %rbp
  10027b:	48 89 e5             	mov    %rsp,%rbp
  10027e:	48 83 ec 40          	sub    $0x40,%rsp
  100282:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  100286:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  10028a:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  10028e:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
  100292:	4c 89 45 c8          	mov    %r8,-0x38(%rbp)
    SysCallR sysCall = sysCalls[rax]; // sysCalls es un arreglo de punteros a funcion, me guardo la funcion que corresponde con el valor de rax
  100296:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  10029a:	48 8b 04 c5 00 30 10 	mov    0x103000(,%rax,8),%rax
  1002a1:	00 
  1002a2:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if (sysCall != 0) // si no se encuentra en la lista, al estar inicializado con ceros el arreglo, me devuelve cero
  1002a6:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  1002ab:	74 18                	je     1002c5 <sysCallDispatcher+0x4b>
        return sysCall(rdi, rsi, rdx, rcx);
  1002ad:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
  1002b1:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  1002b5:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  1002b9:	48 8b 7d e8          	mov    -0x18(%rbp),%rdi
  1002bd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  1002c1:	ff d0                	callq  *%rax
  1002c3:	eb 05                	jmp    1002ca <sysCallDispatcher+0x50>
    
    return 0;
  1002c5:	b8 00 00 00 00       	mov    $0x0,%eax
}
  1002ca:	c9                   	leaveq 
  1002cb:	c3                   	retq   

00000000001002cc <clear>:

void clear() {
  1002cc:	55                   	push   %rbp
  1002cd:	48 89 e5             	mov    %rsp,%rbp
    ncClear();
  1002d0:	b8 00 00 00 00       	mov    $0x0,%eax
  1002d5:	e8 c6 0e 00 00       	callq  1011a0 <ncClear>
}
  1002da:	5d                   	pop    %rbp
  1002db:	c3                   	retq   

00000000001002dc <timerTick>:

long timerTick(void (*f)()) {
  1002dc:	55                   	push   %rbp
  1002dd:	48 89 e5             	mov    %rsp,%rbp
  1002e0:	48 83 ec 10          	sub    $0x10,%rsp
  1002e4:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
    set_routine(f);
  1002e8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  1002ec:	48 89 c7             	mov    %rax,%rdi
  1002ef:	e8 3f ff ff ff       	callq  100233 <set_routine>
    return ticks_elapsed();
  1002f4:	b8 00 00 00 00       	mov    $0x0,%eax
  1002f9:	e8 4e ff ff ff       	callq  10024c <ticks_elapsed>
  1002fe:	48 98                	cltq   
}
  100300:	c9                   	leaveq 
  100301:	c3                   	retq   

0000000000100302 <write>:

long write(unsigned int fd,char * buf, uint64_t count, char color) {
  100302:	55                   	push   %rbp
  100303:	48 89 e5             	mov    %rsp,%rbp
  100306:	48 83 ec 30          	sub    $0x30,%rsp
  10030a:	89 7d ec             	mov    %edi,-0x14(%rbp)
  10030d:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  100311:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  100315:	89 c8                	mov    %ecx,%eax
  100317:	88 45 e8             	mov    %al,-0x18(%rbp)
    if (buf == NULL)
  10031a:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  10031f:	75 0c                	jne    10032d <write+0x2b>
        return -1;
  100321:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  100328:	e9 b3 00 00 00       	jmpq   1003e0 <write+0xde>
    if (fd == STDERR)
  10032d:	83 7d ec 02          	cmpl   $0x2,-0x14(%rbp)
  100331:	75 06                	jne    100339 <write+0x37>
        color = RED;
  100333:	c6 45 e8 04          	movb   $0x4,-0x18(%rbp)
  100337:	eb 12                	jmp    10034b <write+0x49>
    else if (fd != STDOUT) {
  100339:	83 7d ec 01          	cmpl   $0x1,-0x14(%rbp)
  10033d:	74 0c                	je     10034b <write+0x49>
        return -1;
  10033f:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  100346:	e9 95 00 00 00       	jmpq   1003e0 <write+0xde>
    }


    int i;
    for (i =0 ; buf[i] && i <count ; i++) {
  10034b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  100352:	eb 59                	jmp    1003ad <write+0xab>
        switch(buf[i]) {
  100354:	8b 45 fc             	mov    -0x4(%rbp),%eax
  100357:	48 63 d0             	movslq %eax,%rdx
  10035a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  10035e:	48 01 d0             	add    %rdx,%rax
  100361:	0f b6 00             	movzbl (%rax),%eax
  100364:	0f be c0             	movsbl %al,%eax
  100367:	83 f8 08             	cmp    $0x8,%eax
  10036a:	74 11                	je     10037d <write+0x7b>
  10036c:	83 f8 0a             	cmp    $0xa,%eax
  10036f:	75 18                	jne    100389 <write+0x87>
            case '\n':
                ncNewline();
  100371:	b8 00 00 00 00       	mov    $0x0,%eax
  100376:	e8 f1 0c 00 00       	callq  10106c <ncNewline>
            break;
  10037b:	eb 2c                	jmp    1003a9 <write+0xa7>
            case '\b':
                 ncDelete();
  10037d:	b8 00 00 00 00       	mov    $0x0,%eax
  100382:	e8 25 0d 00 00       	callq  1010ac <ncDelete>
            break;
  100387:	eb 20                	jmp    1003a9 <write+0xa7>
            default:
                    ncPrintChar(buf[i], color);
  100389:	0f be 55 e8          	movsbl -0x18(%rbp),%edx
  10038d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  100390:	48 63 c8             	movslq %eax,%rcx
  100393:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  100397:	48 01 c8             	add    %rcx,%rax
  10039a:	0f b6 00             	movzbl (%rax),%eax
  10039d:	0f be c0             	movsbl %al,%eax
  1003a0:	89 d6                	mov    %edx,%esi
  1003a2:	89 c7                	mov    %eax,%edi
  1003a4:	e8 81 0c 00 00       	callq  10102a <ncPrintChar>
    for (i =0 ; buf[i] && i <count ; i++) {
  1003a9:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  1003ad:	8b 45 fc             	mov    -0x4(%rbp),%eax
  1003b0:	48 63 d0             	movslq %eax,%rdx
  1003b3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  1003b7:	48 01 d0             	add    %rdx,%rax
  1003ba:	0f b6 00             	movzbl (%rax),%eax
  1003bd:	84 c0                	test   %al,%al
  1003bf:	74 0b                	je     1003cc <write+0xca>
  1003c1:	8b 45 fc             	mov    -0x4(%rbp),%eax
  1003c4:	48 98                	cltq   
  1003c6:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  1003ca:	72 88                	jb     100354 <write+0x52>
        }
    }
    return i > 0 ? i : -1;
  1003cc:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  1003d0:	7e 07                	jle    1003d9 <write+0xd7>
  1003d2:	8b 45 fc             	mov    -0x4(%rbp),%eax
  1003d5:	48 98                	cltq   
  1003d7:	eb 07                	jmp    1003e0 <write+0xde>
  1003d9:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
}
  1003e0:	c9                   	leaveq 
  1003e1:	c3                   	retq   

00000000001003e2 <read>:

long read(unsigned int fd, char * buf, uint64_t count) {
  1003e2:	55                   	push   %rbp
  1003e3:	48 89 e5             	mov    %rsp,%rbp
  1003e6:	48 83 ec 20          	sub    $0x20,%rsp
  1003ea:	89 7d fc             	mov    %edi,-0x4(%rbp)
  1003ed:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  1003f1:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
    if (fd != 0)
  1003f5:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  1003f9:	74 09                	je     100404 <read+0x22>
        return -1; // solo acepta teclado
  1003fb:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  100402:	eb 1a                	jmp    10041e <read+0x3c>
    return readFromKeyboard(buf, count,1);
  100404:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  100408:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  10040c:	ba 01 00 00 00       	mov    $0x1,%edx
  100411:	48 89 ce             	mov    %rcx,%rsi
  100414:	48 89 c7             	mov    %rax,%rdi
  100417:	e8 75 12 00 00       	callq  101691 <readFromKeyboard>
  10041c:	48 98                	cltq   
}
  10041e:	c9                   	leaveq 
  10041f:	c3                   	retq   

0000000000100420 <getChar>:

int getChar(unsigned int ascii) {
  100420:	55                   	push   %rbp
  100421:	48 89 e5             	mov    %rsp,%rbp
  100424:	48 83 ec 20          	sub    $0x20,%rsp
  100428:	89 7d ec             	mov    %edi,-0x14(%rbp)
    int a;
         for(int i=0 ; i<1 ; i++) {
  10042b:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
  100432:	eb 45                	jmp    100479 <getChar+0x59>
          a = kb_read();
  100434:	b8 00 00 00 00       	mov    $0x0,%eax
  100439:	e8 be 11 00 00       	callq  1015fc <kb_read>
  10043e:	89 45 fc             	mov    %eax,-0x4(%rbp)
          if (ascii && !PRINTABLE(a))
  100441:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  100445:	74 2e                	je     100475 <getChar+0x55>
  100447:	83 7d fc 3a          	cmpl   $0x3a,-0x4(%rbp)
  10044b:	74 24                	je     100471 <getChar+0x51>
  10044d:	81 7d fc f5 01 00 00 	cmpl   $0x1f5,-0x4(%rbp)
  100454:	74 1b                	je     100471 <getChar+0x51>
  100456:	81 7d fc f6 01 00 00 	cmpl   $0x1f6,-0x4(%rbp)
  10045d:	74 12                	je     100471 <getChar+0x51>
  10045f:	81 7d fc f7 01 00 00 	cmpl   $0x1f7,-0x4(%rbp)
  100466:	74 09                	je     100471 <getChar+0x51>
  100468:	81 7d fc f8 01 00 00 	cmpl   $0x1f8,-0x4(%rbp)
  10046f:	75 04                	jne    100475 <getChar+0x55>
               i--;
  100471:	83 6d f8 01          	subl   $0x1,-0x8(%rbp)
         for(int i=0 ; i<1 ; i++) {
  100475:	83 45 f8 01          	addl   $0x1,-0x8(%rbp)
  100479:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  10047d:	7e b5                	jle    100434 <getChar+0x14>
     }
     return a;
  10047f:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  100482:	c9                   	leaveq 
  100483:	c3                   	retq   

0000000000100484 <splitScreen>:

static int splitScreen(int screens, int screen) {
  100484:	55                   	push   %rbp
  100485:	48 89 e5             	mov    %rsp,%rbp
  100488:	48 83 ec 10          	sub    $0x10,%rsp
  10048c:	89 7d fc             	mov    %edi,-0x4(%rbp)
  10048f:	89 75 f8             	mov    %esi,-0x8(%rbp)
    return ncSplitConsole(screens, screen);
  100492:	8b 55 f8             	mov    -0x8(%rbp),%edx
  100495:	8b 45 fc             	mov    -0x4(%rbp),%eax
  100498:	89 d6                	mov    %edx,%esi
  10049a:	89 c7                	mov    %eax,%edi
  10049c:	e8 0f 05 00 00       	callq  1009b0 <ncSplitConsole>
}
  1004a1:	c9                   	leaveq 
  1004a2:	c3                   	retq   

00000000001004a3 <changeScreen>:
static int changeScreen(int screen) {
  1004a3:	55                   	push   %rbp
  1004a4:	48 89 e5             	mov    %rsp,%rbp
  1004a7:	48 83 ec 10          	sub    $0x10,%rsp
  1004ab:	89 7d fc             	mov    %edi,-0x4(%rbp)
    return ncChangeScreen(screen);
  1004ae:	8b 45 fc             	mov    -0x4(%rbp),%eax
  1004b1:	89 c7                	mov    %eax,%edi
  1004b3:	e8 87 08 00 00       	callq  100d3f <ncChangeScreen>
}
  1004b8:	c9                   	leaveq 
  1004b9:	c3                   	retq   

00000000001004ba <numToStr>:

int numToStr(int num, char * str) {
  1004ba:	55                   	push   %rbp
  1004bb:	48 89 e5             	mov    %rsp,%rbp
  1004be:	48 83 ec 30          	sub    $0x30,%rsp
  1004c2:	89 7d dc             	mov    %edi,-0x24(%rbp)
  1004c5:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
    if (num == 0) {
  1004c9:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  1004cd:	75 11                	jne    1004e0 <numToStr+0x26>
        str[0] = '0';
  1004cf:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  1004d3:	c6 00 30             	movb   $0x30,(%rax)
        return 1;
  1004d6:	b8 01 00 00 00       	mov    $0x1,%eax
  1004db:	e9 d3 00 00 00       	jmpq   1005b3 <numToStr+0xf9>
    }
	int neg=0;
  1004e0:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	if (num<0) {
  1004e7:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  1004eb:	79 16                	jns    100503 <numToStr+0x49>
		str[0]='-';
  1004ed:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  1004f1:	c6 00 2d             	movb   $0x2d,(%rax)
		str++;
  1004f4:	48 83 45 d0 01       	addq   $0x1,-0x30(%rbp)
		num=num*(-1);
  1004f9:	f7 5d dc             	negl   -0x24(%rbp)
		neg=1;
  1004fc:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%rbp)
	}	
	int i, rem, n, len = 0;
  100503:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%rbp)
	n = num;
  10050a:	8b 45 dc             	mov    -0x24(%rbp),%eax
  10050d:	89 45 f4             	mov    %eax,-0xc(%rbp)
	while (n != 0) {
  100510:	eb 1f                	jmp    100531 <numToStr+0x77>
	  len++;
  100512:	83 45 f0 01          	addl   $0x1,-0x10(%rbp)
	  n /= 10;
  100516:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  100519:	ba 67 66 66 66       	mov    $0x66666667,%edx
  10051e:	89 c8                	mov    %ecx,%eax
  100520:	f7 ea                	imul   %edx
  100522:	c1 fa 02             	sar    $0x2,%edx
  100525:	89 c8                	mov    %ecx,%eax
  100527:	c1 f8 1f             	sar    $0x1f,%eax
  10052a:	29 c2                	sub    %eax,%edx
  10052c:	89 d0                	mov    %edx,%eax
  10052e:	89 45 f4             	mov    %eax,-0xc(%rbp)
	while (n != 0) {
  100531:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  100535:	75 db                	jne    100512 <numToStr+0x58>
	}
	for (i = 0; i < len; i++) {
  100537:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
  10053e:	eb 63                	jmp    1005a3 <numToStr+0xe9>
	  rem = num % 10;
  100540:	8b 4d dc             	mov    -0x24(%rbp),%ecx
  100543:	ba 67 66 66 66       	mov    $0x66666667,%edx
  100548:	89 c8                	mov    %ecx,%eax
  10054a:	f7 ea                	imul   %edx
  10054c:	c1 fa 02             	sar    $0x2,%edx
  10054f:	89 c8                	mov    %ecx,%eax
  100551:	c1 f8 1f             	sar    $0x1f,%eax
  100554:	29 c2                	sub    %eax,%edx
  100556:	89 d0                	mov    %edx,%eax
  100558:	c1 e0 02             	shl    $0x2,%eax
  10055b:	01 d0                	add    %edx,%eax
  10055d:	01 c0                	add    %eax,%eax
  10055f:	29 c1                	sub    %eax,%ecx
  100561:	89 c8                	mov    %ecx,%eax
  100563:	89 45 ec             	mov    %eax,-0x14(%rbp)
	  num = num / 10;
  100566:	8b 4d dc             	mov    -0x24(%rbp),%ecx
  100569:	ba 67 66 66 66       	mov    $0x66666667,%edx
  10056e:	89 c8                	mov    %ecx,%eax
  100570:	f7 ea                	imul   %edx
  100572:	c1 fa 02             	sar    $0x2,%edx
  100575:	89 c8                	mov    %ecx,%eax
  100577:	c1 f8 1f             	sar    $0x1f,%eax
  10057a:	29 c2                	sub    %eax,%edx
  10057c:	89 d0                	mov    %edx,%eax
  10057e:	89 45 dc             	mov    %eax,-0x24(%rbp)
	  str[len - (i + 1)] = rem + '0';
  100581:	8b 45 f8             	mov    -0x8(%rbp),%eax
  100584:	f7 d0                	not    %eax
  100586:	89 c2                	mov    %eax,%edx
  100588:	8b 45 f0             	mov    -0x10(%rbp),%eax
  10058b:	01 d0                	add    %edx,%eax
  10058d:	48 63 d0             	movslq %eax,%rdx
  100590:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  100594:	48 01 d0             	add    %rdx,%rax
  100597:	8b 55 ec             	mov    -0x14(%rbp),%edx
  10059a:	83 c2 30             	add    $0x30,%edx
  10059d:	88 10                	mov    %dl,(%rax)
	for (i = 0; i < len; i++) {
  10059f:	83 45 f8 01          	addl   $0x1,-0x8(%rbp)
  1005a3:	8b 45 f8             	mov    -0x8(%rbp),%eax
  1005a6:	3b 45 f0             	cmp    -0x10(%rbp),%eax
  1005a9:	7c 95                	jl     100540 <numToStr+0x86>
	}
	return len+neg;
  1005ab:	8b 55 f0             	mov    -0x10(%rbp),%edx
  1005ae:	8b 45 fc             	mov    -0x4(%rbp),%eax
  1005b1:	01 d0                	add    %edx,%eax
}
  1005b3:	c9                   	leaveq 
  1005b4:	c3                   	retq   

00000000001005b5 <getTime>:

void getTime(char * buf) {
  1005b5:	55                   	push   %rbp
  1005b6:	48 89 e5             	mov    %rsp,%rbp
  1005b9:	48 83 ec 20          	sub    $0x20,%rsp
  1005bd:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    buf[0] = buf[3] = buf[6] = '0';
  1005c1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  1005c5:	48 83 c0 03          	add    $0x3,%rax
  1005c9:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  1005cd:	48 83 c2 06          	add    $0x6,%rdx
  1005d1:	c6 02 30             	movb   $0x30,(%rdx)
  1005d4:	0f b6 12             	movzbl (%rdx),%edx
  1005d7:	88 10                	mov    %dl,(%rax)
  1005d9:	0f b6 10             	movzbl (%rax),%edx
  1005dc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  1005e0:	88 10                	mov    %dl,(%rax)
    buf[2] = buf[5] = ':';
  1005e2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  1005e6:	48 8d 50 02          	lea    0x2(%rax),%rdx
  1005ea:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  1005ee:	48 83 c0 05          	add    $0x5,%rax
  1005f2:	c6 00 3a             	movb   $0x3a,(%rax)
  1005f5:	0f b6 00             	movzbl (%rax),%eax
  1005f8:	88 02                	mov    %al,(%rdx)
    int h = hours();
  1005fa:	b8 00 00 00 00       	mov    $0x0,%eax
  1005ff:	e8 02 02 00 00       	callq  100806 <hours>
  100604:	89 45 fc             	mov    %eax,-0x4(%rbp)
    if (h<10)
  100607:	83 7d fc 09          	cmpl   $0x9,-0x4(%rbp)
  10060b:	7f 17                	jg     100624 <getTime+0x6f>
        numToStr(h,&buf[1]);
  10060d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  100611:	48 8d 50 01          	lea    0x1(%rax),%rdx
  100615:	8b 45 fc             	mov    -0x4(%rbp),%eax
  100618:	48 89 d6             	mov    %rdx,%rsi
  10061b:	89 c7                	mov    %eax,%edi
  10061d:	e8 98 fe ff ff       	callq  1004ba <numToStr>
  100622:	eb 11                	jmp    100635 <getTime+0x80>
    else numToStr(h,&buf[0]);
  100624:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  100628:	8b 45 fc             	mov    -0x4(%rbp),%eax
  10062b:	48 89 d6             	mov    %rdx,%rsi
  10062e:	89 c7                	mov    %eax,%edi
  100630:	e8 85 fe ff ff       	callq  1004ba <numToStr>

    int m = minutes();
  100635:	b8 00 00 00 00       	mov    $0x0,%eax
  10063a:	e8 ad 01 00 00       	callq  1007ec <minutes>
  10063f:	89 45 f8             	mov    %eax,-0x8(%rbp)

    if (m<10)
  100642:	83 7d f8 09          	cmpl   $0x9,-0x8(%rbp)
  100646:	7f 17                	jg     10065f <getTime+0xaa>
        numToStr(m,&buf[4]);
  100648:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  10064c:	48 8d 50 04          	lea    0x4(%rax),%rdx
  100650:	8b 45 f8             	mov    -0x8(%rbp),%eax
  100653:	48 89 d6             	mov    %rdx,%rsi
  100656:	89 c7                	mov    %eax,%edi
  100658:	e8 5d fe ff ff       	callq  1004ba <numToStr>
  10065d:	eb 15                	jmp    100674 <getTime+0xbf>
    else numToStr(m,&buf[3]);
  10065f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  100663:	48 8d 50 03          	lea    0x3(%rax),%rdx
  100667:	8b 45 f8             	mov    -0x8(%rbp),%eax
  10066a:	48 89 d6             	mov    %rdx,%rsi
  10066d:	89 c7                	mov    %eax,%edi
  10066f:	e8 46 fe ff ff       	callq  1004ba <numToStr>

    int s = seconds();
  100674:	b8 00 00 00 00       	mov    $0x0,%eax
  100679:	e8 54 01 00 00       	callq  1007d2 <seconds>
  10067e:	89 45 f4             	mov    %eax,-0xc(%rbp)

    if (s<10)
  100681:	83 7d f4 09          	cmpl   $0x9,-0xc(%rbp)
  100685:	7f 17                	jg     10069e <getTime+0xe9>
        numToStr(s,&buf[7]);
  100687:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  10068b:	48 8d 50 07          	lea    0x7(%rax),%rdx
  10068f:	8b 45 f4             	mov    -0xc(%rbp),%eax
  100692:	48 89 d6             	mov    %rdx,%rsi
  100695:	89 c7                	mov    %eax,%edi
  100697:	e8 1e fe ff ff       	callq  1004ba <numToStr>
  10069c:	eb 15                	jmp    1006b3 <getTime+0xfe>
    else numToStr(s,&buf[6]);
  10069e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  1006a2:	48 8d 50 06          	lea    0x6(%rax),%rdx
  1006a6:	8b 45 f4             	mov    -0xc(%rbp),%eax
  1006a9:	48 89 d6             	mov    %rdx,%rsi
  1006ac:	89 c7                	mov    %eax,%edi
  1006ae:	e8 07 fe ff ff       	callq  1004ba <numToStr>
    buf[8] = 0;
  1006b3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  1006b7:	48 83 c0 08          	add    $0x8,%rax
  1006bb:	c6 00 00             	movb   $0x0,(%rax)
}
  1006be:	c9                   	leaveq 
  1006bf:	c3                   	retq   

00000000001006c0 <getDate>:

void getDate(char * buf) {
  1006c0:	55                   	push   %rbp
  1006c1:	48 89 e5             	mov    %rsp,%rbp
  1006c4:	48 83 ec 20          	sub    $0x20,%rsp
  1006c8:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    buf[0] = buf[3] = '0';
  1006cc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  1006d0:	48 83 c0 03          	add    $0x3,%rax
  1006d4:	c6 00 30             	movb   $0x30,(%rax)
  1006d7:	0f b6 10             	movzbl (%rax),%edx
  1006da:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  1006de:	88 10                	mov    %dl,(%rax)
    buf[2] = buf[5] = '/';
  1006e0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  1006e4:	48 8d 50 02          	lea    0x2(%rax),%rdx
  1006e8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  1006ec:	48 83 c0 05          	add    $0x5,%rax
  1006f0:	c6 00 2f             	movb   $0x2f,(%rax)
  1006f3:	0f b6 00             	movzbl (%rax),%eax
  1006f6:	88 02                	mov    %al,(%rdx)

    int m = month();
  1006f8:	b8 00 00 00 00       	mov    $0x0,%eax
  1006fd:	e8 3b 01 00 00       	callq  10083d <month>
  100702:	89 45 fc             	mov    %eax,-0x4(%rbp)

    if (m<10)
  100705:	83 7d fc 09          	cmpl   $0x9,-0x4(%rbp)
  100709:	7f 17                	jg     100722 <getDate+0x62>
        numToStr(m,&buf[1]);
  10070b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  10070f:	48 8d 50 01          	lea    0x1(%rax),%rdx
  100713:	8b 45 fc             	mov    -0x4(%rbp),%eax
  100716:	48 89 d6             	mov    %rdx,%rsi
  100719:	89 c7                	mov    %eax,%edi
  10071b:	e8 9a fd ff ff       	callq  1004ba <numToStr>
  100720:	eb 11                	jmp    100733 <getDate+0x73>
    else numToStr(m,&buf[0]);
  100722:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  100726:	8b 45 fc             	mov    -0x4(%rbp),%eax
  100729:	48 89 d6             	mov    %rdx,%rsi
  10072c:	89 c7                	mov    %eax,%edi
  10072e:	e8 87 fd ff ff       	callq  1004ba <numToStr>

    int d = day();
  100733:	b8 00 00 00 00       	mov    $0x0,%eax
  100738:	e8 e6 00 00 00       	callq  100823 <day>
  10073d:	89 45 f8             	mov    %eax,-0x8(%rbp)

    if (d<10)
  100740:	83 7d f8 09          	cmpl   $0x9,-0x8(%rbp)
  100744:	7f 17                	jg     10075d <getDate+0x9d>
        numToStr(d,&buf[4]);
  100746:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  10074a:	48 8d 50 04          	lea    0x4(%rax),%rdx
  10074e:	8b 45 f8             	mov    -0x8(%rbp),%eax
  100751:	48 89 d6             	mov    %rdx,%rsi
  100754:	89 c7                	mov    %eax,%edi
  100756:	e8 5f fd ff ff       	callq  1004ba <numToStr>
  10075b:	eb 15                	jmp    100772 <getDate+0xb2>
    else numToStr(d,&buf[3]);
  10075d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  100761:	48 8d 50 03          	lea    0x3(%rax),%rdx
  100765:	8b 45 f8             	mov    -0x8(%rbp),%eax
  100768:	48 89 d6             	mov    %rdx,%rsi
  10076b:	89 c7                	mov    %eax,%edi
  10076d:	e8 48 fd ff ff       	callq  1004ba <numToStr>

    int y = year();
  100772:	b8 00 00 00 00       	mov    $0x0,%eax
  100777:	e8 db 00 00 00       	callq  100857 <year>
  10077c:	89 45 f4             	mov    %eax,-0xc(%rbp)
    numToStr(y,&buf[6]);
  10077f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  100783:	48 8d 50 06          	lea    0x6(%rax),%rdx
  100787:	8b 45 f4             	mov    -0xc(%rbp),%eax
  10078a:	48 89 d6             	mov    %rdx,%rsi
  10078d:	89 c7                	mov    %eax,%edi
  10078f:	e8 26 fd ff ff       	callq  1004ba <numToStr>
    buf[8] = 0;
  100794:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  100798:	48 83 c0 08          	add    $0x8,%rax
  10079c:	c6 00 00             	movb   $0x0,(%rax)
}
  10079f:	c9                   	leaveq 
  1007a0:	c3                   	retq   

00000000001007a1 <BCDToDecimal>:
#define DATETIME_LENGTH (DATE_LENGTH + 3 + TIME_LENGTH)
#define TIME_LENGTH 8
#define DATE_LENGTH 10 


int BCDToDecimal(uint64_t value) {
  1007a1:	55                   	push   %rbp
  1007a2:	48 89 e5             	mov    %rsp,%rbp
  1007a5:	48 83 ec 08          	sub    $0x8,%rsp
  1007a9:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
    return ((value & 0xF0) >> 4) * 10 + (value & 0x0F);
  1007ad:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  1007b1:	25 f0 00 00 00       	and    $0xf0,%eax
  1007b6:	48 c1 e8 04          	shr    $0x4,%rax
  1007ba:	89 c2                	mov    %eax,%edx
  1007bc:	89 d0                	mov    %edx,%eax
  1007be:	c1 e0 02             	shl    $0x2,%eax
  1007c1:	01 d0                	add    %edx,%eax
  1007c3:	01 c0                	add    %eax,%eax
  1007c5:	89 c2                	mov    %eax,%edx
  1007c7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  1007cb:	83 e0 0f             	and    $0xf,%eax
  1007ce:	01 d0                	add    %edx,%eax
}
  1007d0:	c9                   	leaveq 
  1007d1:	c3                   	retq   

00000000001007d2 <seconds>:

unsigned int seconds() {
  1007d2:	55                   	push   %rbp
  1007d3:	48 89 e5             	mov    %rsp,%rbp
    return BCDToDecimal(getRTC(SECONDS));
  1007d6:	bf 00 00 00 00       	mov    $0x0,%edi
  1007db:	e8 d9 12 00 00       	callq  101ab9 <getRTC>
  1007e0:	48 98                	cltq   
  1007e2:	48 89 c7             	mov    %rax,%rdi
  1007e5:	e8 b7 ff ff ff       	callq  1007a1 <BCDToDecimal>
}
  1007ea:	5d                   	pop    %rbp
  1007eb:	c3                   	retq   

00000000001007ec <minutes>:

unsigned int minutes() {
  1007ec:	55                   	push   %rbp
  1007ed:	48 89 e5             	mov    %rsp,%rbp
    return BCDToDecimal(getRTC(MINUTES));
  1007f0:	bf 02 00 00 00       	mov    $0x2,%edi
  1007f5:	e8 bf 12 00 00       	callq  101ab9 <getRTC>
  1007fa:	48 98                	cltq   
  1007fc:	48 89 c7             	mov    %rax,%rdi
  1007ff:	e8 9d ff ff ff       	callq  1007a1 <BCDToDecimal>
}
  100804:	5d                   	pop    %rbp
  100805:	c3                   	retq   

0000000000100806 <hours>:

unsigned int hours() {
  100806:	55                   	push   %rbp
  100807:	48 89 e5             	mov    %rsp,%rbp
    return BCDToDecimal(getRTC(HOURS))+TIMEZONE_DIFF;
  10080a:	bf 04 00 00 00       	mov    $0x4,%edi
  10080f:	e8 a5 12 00 00       	callq  101ab9 <getRTC>
  100814:	48 98                	cltq   
  100816:	48 89 c7             	mov    %rax,%rdi
  100819:	e8 83 ff ff ff       	callq  1007a1 <BCDToDecimal>
  10081e:	83 e8 03             	sub    $0x3,%eax
}
  100821:	5d                   	pop    %rbp
  100822:	c3                   	retq   

0000000000100823 <day>:

unsigned int day() {
  100823:	55                   	push   %rbp
  100824:	48 89 e5             	mov    %rsp,%rbp
    return BCDToDecimal(getRTC(DAY));
  100827:	bf 07 00 00 00       	mov    $0x7,%edi
  10082c:	e8 88 12 00 00       	callq  101ab9 <getRTC>
  100831:	48 98                	cltq   
  100833:	48 89 c7             	mov    %rax,%rdi
  100836:	e8 66 ff ff ff       	callq  1007a1 <BCDToDecimal>
}
  10083b:	5d                   	pop    %rbp
  10083c:	c3                   	retq   

000000000010083d <month>:

unsigned int month() {
  10083d:	55                   	push   %rbp
  10083e:	48 89 e5             	mov    %rsp,%rbp
    return BCDToDecimal(getRTC(MONTH));
  100841:	bf 08 00 00 00       	mov    $0x8,%edi
  100846:	e8 6e 12 00 00       	callq  101ab9 <getRTC>
  10084b:	48 98                	cltq   
  10084d:	48 89 c7             	mov    %rax,%rdi
  100850:	e8 4c ff ff ff       	callq  1007a1 <BCDToDecimal>
}
  100855:	5d                   	pop    %rbp
  100856:	c3                   	retq   

0000000000100857 <year>:

unsigned int year() {
  100857:	55                   	push   %rbp
  100858:	48 89 e5             	mov    %rsp,%rbp
    return BCDToDecimal(getRTC(YEAR));
  10085b:	bf 09 00 00 00       	mov    $0x9,%edi
  100860:	e8 54 12 00 00       	callq  101ab9 <getRTC>
  100865:	48 98                	cltq   
  100867:	48 89 c7             	mov    %rax,%rdi
  10086a:	e8 32 ff ff ff       	callq  1007a1 <BCDToDecimal>
}
  10086f:	5d                   	pop    %rbp
  100870:	c3                   	retq   

0000000000100871 <irqDispatcher>:

static void int_20();
static void int_21();
static IRQHandlerR handlers[8] = {(IRQHandlerR) &int_20, (IRQHandlerR) &int_21};

void irqDispatcher(uint64_t irq) {
  100871:	55                   	push   %rbp
  100872:	48 89 e5             	mov    %rsp,%rbp
  100875:	48 83 ec 20          	sub    $0x20,%rsp
  100879:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	IRQHandlerR irqHandler = handlers[irq];
  10087d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  100881:	48 8b 04 c5 00 38 10 	mov    0x103800(,%rax,8),%rax
  100888:	00 
  100889:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	if (irqHandler != 0)
  10088d:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  100892:	74 0b                	je     10089f <irqDispatcher+0x2e>
		irqHandler();
  100894:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  100898:	b8 00 00 00 00       	mov    $0x0,%eax
  10089d:	ff d2                	callq  *%rdx
}
  10089f:	c9                   	leaveq 
  1008a0:	c3                   	retq   

00000000001008a1 <int_20>:

void int_20() {
  1008a1:	55                   	push   %rbp
  1008a2:	48 89 e5             	mov    %rsp,%rbp
	//ncPrint("timer");
	 timer_handler();
  1008a5:	b8 00 00 00 00       	mov    $0x0,%eax
  1008aa:	e8 6c f9 ff ff       	callq  10021b <timer_handler>
}
  1008af:	5d                   	pop    %rbp
  1008b0:	c3                   	retq   

00000000001008b1 <int_21>:

void int_21() {
  1008b1:	55                   	push   %rbp
  1008b2:	48 89 e5             	mov    %rsp,%rbp
	keyboardDriver();
  1008b5:	b8 00 00 00 00       	mov    $0x0,%eax
  1008ba:	e8 61 0d 00 00       	callq  101620 <keyboardDriver>
}
  1008bf:	5d                   	pop    %rbp
  1008c0:	c3                   	retq   

00000000001008c1 <exceptionDispatcher>:
#define INVALID_OP_EXCEPTION_ID 6

static void zero_division();
static void invalid_op();

void exceptionDispatcher(int exception, uint64_t * regs) {
  1008c1:	55                   	push   %rbp
  1008c2:	48 89 e5             	mov    %rsp,%rbp
  1008c5:	48 83 ec 10          	sub    $0x10,%rsp
  1008c9:	89 7d fc             	mov    %edi,-0x4(%rbp)
  1008cc:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	switch(exception) {
  1008d0:	8b 45 fc             	mov    -0x4(%rbp),%eax
  1008d3:	85 c0                	test   %eax,%eax
  1008d5:	74 07                	je     1008de <exceptionDispatcher+0x1d>
  1008d7:	83 f8 06             	cmp    $0x6,%eax
  1008da:	74 0e                	je     1008ea <exceptionDispatcher+0x29>
  1008dc:	eb 17                	jmp    1008f5 <exceptionDispatcher+0x34>
		case ZERO_EXCEPTION_ID:
		zero_division();
  1008de:	b8 00 00 00 00       	mov    $0x0,%eax
  1008e3:	e8 0f 00 00 00       	callq  1008f7 <zero_division>
		break;
  1008e8:	eb 0b                	jmp    1008f5 <exceptionDispatcher+0x34>
		case INVALID_OP_EXCEPTION_ID:
		invalid_op();
  1008ea:	b8 00 00 00 00       	mov    $0x0,%eax
  1008ef:	e8 09 00 00 00       	callq  1008fd <invalid_op>
		break;
  1008f4:	90                   	nop
	}
	// ACA HABRIA QUE IMPRIMIR LOS REGISTROS QUE SE PASARON EN 'regs' (provienen del pushState en el codigo asm)
}
  1008f5:	c9                   	leaveq 
  1008f6:	c3                   	retq   

00000000001008f7 <zero_division>:

static void zero_division() {
  1008f7:	55                   	push   %rbp
  1008f8:	48 89 e5             	mov    %rsp,%rbp
	// Handler para manejar excepcíon
}
  1008fb:	5d                   	pop    %rbp
  1008fc:	c3                   	retq   

00000000001008fd <invalid_op>:

static void invalid_op() {
  1008fd:	55                   	push   %rbp
  1008fe:	48 89 e5             	mov    %rsp,%rbp
	// Handler para manejar excepcíon
  100901:	5d                   	pop    %rbp
  100902:	c3                   	retq   

0000000000100903 <ncInitVideoConsole>:

// void setPointer(uint8_t ptr) {
// 	currentVideo = ptr;
// }

void ncInitVideoConsole() {
  100903:	55                   	push   %rbp
  100904:	48 89 e5             	mov    %rsp,%rbp
	shift = 0;
  100907:	c7 05 b3 37 00 00 00 	movl   $0x0,0x37b3(%rip)        # 1040c4 <shift>
  10090e:	00 00 00 
	width = WIDTH;
  100911:	c7 05 75 2f 00 00 50 	movl   $0x50,0x2f75(%rip)        # 103890 <width>
  100918:	00 00 00 
	height = HEIGHT;
  10091b:	c7 05 6f 2f 00 00 19 	movl   $0x19,0x2f6f(%rip)        # 103894 <height>
  100922:	00 00 00 
	video = VIDEO_PTR;
  100925:	48 c7 05 50 2f 00 00 	movq   $0xb7ffe,0x2f50(%rip)        # 103880 <video>
  10092c:	fe 7f 0b 00 
	currentVideo = video;
  100930:	48 8b 05 49 2f 00 00 	mov    0x2f49(%rip),%rax        # 103880 <video>
  100937:	48 89 05 4a 2f 00 00 	mov    %rax,0x2f4a(%rip)        # 103888 <currentVideo>
	counterMax = width*height;
  10093e:	8b 15 4c 2f 00 00    	mov    0x2f4c(%rip),%edx        # 103890 <width>
  100944:	8b 05 4a 2f 00 00    	mov    0x2f4a(%rip),%eax        # 103894 <height>
  10094a:	0f af c2             	imul   %edx,%eax
  10094d:	89 05 79 37 00 00    	mov    %eax,0x3779(%rip)        # 1040cc <counterMax>
	position =0;
  100953:	c7 05 6b 37 00 00 00 	movl   $0x0,0x376b(%rip)        # 1040c8 <position>
  10095a:	00 00 00 
	twoScreensAux[0].ptr = twoScreensAux[1].ptr = fourScreensAux[0].ptr = fourScreensAux[1].ptr = fourScreensAux[2].ptr = fourScreensAux[3].ptr = 0;
  10095d:	48 c7 05 50 37 00 00 	movq   $0x0,0x3750(%rip)        # 1040b8 <fourScreensAux+0x38>
  100964:	00 00 00 00 
  100968:	48 8b 05 49 37 00 00 	mov    0x3749(%rip),%rax        # 1040b8 <fourScreensAux+0x38>
  10096f:	48 89 05 32 37 00 00 	mov    %rax,0x3732(%rip)        # 1040a8 <fourScreensAux+0x28>
  100976:	48 8b 05 2b 37 00 00 	mov    0x372b(%rip),%rax        # 1040a8 <fourScreensAux+0x28>
  10097d:	48 89 05 14 37 00 00 	mov    %rax,0x3714(%rip)        # 104098 <fourScreensAux+0x18>
  100984:	48 8b 05 0d 37 00 00 	mov    0x370d(%rip),%rax        # 104098 <fourScreensAux+0x18>
  10098b:	48 89 05 f6 36 00 00 	mov    %rax,0x36f6(%rip)        # 104088 <fourScreensAux+0x8>
  100992:	48 8b 05 ef 36 00 00 	mov    0x36ef(%rip),%rax        # 104088 <fourScreensAux+0x8>
  100999:	48 89 05 b8 36 00 00 	mov    %rax,0x36b8(%rip)        # 104058 <twoScreensAux+0x18>
  1009a0:	48 8b 05 b1 36 00 00 	mov    0x36b1(%rip),%rax        # 104058 <twoScreensAux+0x18>
  1009a7:	48 89 05 9a 36 00 00 	mov    %rax,0x369a(%rip)        # 104048 <twoScreensAux+0x8>
}
  1009ae:	5d                   	pop    %rbp
  1009af:	c3                   	retq   

00000000001009b0 <ncSplitConsole>:


int ncSplitConsole(int screenQty, int screenNum) {
  1009b0:	55                   	push   %rbp
  1009b1:	48 89 e5             	mov    %rsp,%rbp
  1009b4:	48 83 ec 18          	sub    $0x18,%rsp
  1009b8:	89 7d ec             	mov    %edi,-0x14(%rbp)
  1009bb:	89 75 e8             	mov    %esi,-0x18(%rbp)
	position = 0;
  1009be:	c7 05 00 37 00 00 00 	movl   $0x0,0x3700(%rip)        # 1040c8 <position>
  1009c5:	00 00 00 
	twoScreensAux[0].ptr = twoScreensAux[1].ptr = fourScreensAux[0].ptr = fourScreensAux[1].ptr = fourScreensAux[2].ptr = fourScreensAux[3].ptr = 0;
  1009c8:	48 c7 05 e5 36 00 00 	movq   $0x0,0x36e5(%rip)        # 1040b8 <fourScreensAux+0x38>
  1009cf:	00 00 00 00 
  1009d3:	48 8b 05 de 36 00 00 	mov    0x36de(%rip),%rax        # 1040b8 <fourScreensAux+0x38>
  1009da:	48 89 05 c7 36 00 00 	mov    %rax,0x36c7(%rip)        # 1040a8 <fourScreensAux+0x28>
  1009e1:	48 8b 05 c0 36 00 00 	mov    0x36c0(%rip),%rax        # 1040a8 <fourScreensAux+0x28>
  1009e8:	48 89 05 a9 36 00 00 	mov    %rax,0x36a9(%rip)        # 104098 <fourScreensAux+0x18>
  1009ef:	48 8b 05 a2 36 00 00 	mov    0x36a2(%rip),%rax        # 104098 <fourScreensAux+0x18>
  1009f6:	48 89 05 8b 36 00 00 	mov    %rax,0x368b(%rip)        # 104088 <fourScreensAux+0x8>
  1009fd:	48 8b 05 84 36 00 00 	mov    0x3684(%rip),%rax        # 104088 <fourScreensAux+0x8>
  100a04:	48 89 05 4d 36 00 00 	mov    %rax,0x364d(%rip)        # 104058 <twoScreensAux+0x18>
  100a0b:	48 8b 05 46 36 00 00 	mov    0x3646(%rip),%rax        # 104058 <twoScreensAux+0x18>
  100a12:	48 89 05 2f 36 00 00 	mov    %rax,0x362f(%rip)        # 104048 <twoScreensAux+0x8>

	if (!VALID_SCR_QTY(screenQty) || screenNum >= screenQty )
  100a19:	83 7d ec 01          	cmpl   $0x1,-0x14(%rbp)
  100a1d:	74 0c                	je     100a2b <ncSplitConsole+0x7b>
  100a1f:	83 7d ec 02          	cmpl   $0x2,-0x14(%rbp)
  100a23:	74 06                	je     100a2b <ncSplitConsole+0x7b>
  100a25:	83 7d ec 04          	cmpl   $0x4,-0x14(%rbp)
  100a29:	75 08                	jne    100a33 <ncSplitConsole+0x83>
  100a2b:	8b 45 e8             	mov    -0x18(%rbp),%eax
  100a2e:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  100a31:	7c 0a                	jl     100a3d <ncSplitConsole+0x8d>
		return -1;
  100a33:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  100a38:	e9 d8 01 00 00       	jmpq   100c15 <ncSplitConsole+0x265>
		screens = screenQty;
  100a3d:	8b 45 ec             	mov    -0x14(%rbp),%eax
  100a40:	89 05 52 2e 00 00    	mov    %eax,0x2e52(%rip)        # 103898 <screens>
		screen = screenNum;
  100a46:	8b 45 e8             	mov    -0x18(%rbp),%eax
  100a49:	89 05 71 36 00 00    	mov    %eax,0x3671(%rip)        # 1040c0 <screen>
	if (screenQty == 1) {
  100a4f:	83 7d ec 01          	cmpl   $0x1,-0x14(%rbp)
  100a53:	75 56                	jne    100aab <ncSplitConsole+0xfb>
		shift = 0;
  100a55:	c7 05 65 36 00 00 00 	movl   $0x0,0x3665(%rip)        # 1040c4 <shift>
  100a5c:	00 00 00 
		width = WIDTH;
  100a5f:	c7 05 27 2e 00 00 50 	movl   $0x50,0x2e27(%rip)        # 103890 <width>
  100a66:	00 00 00 
		height = HEIGHT;
  100a69:	c7 05 21 2e 00 00 19 	movl   $0x19,0x2e21(%rip)        # 103894 <height>
  100a70:	00 00 00 
		video = VIDEO_PTR;
  100a73:	48 c7 05 02 2e 00 00 	movq   $0xb7ffe,0x2e02(%rip)        # 103880 <video>
  100a7a:	fe 7f 0b 00 
		currentVideo = video;
  100a7e:	48 8b 05 fb 2d 00 00 	mov    0x2dfb(%rip),%rax        # 103880 <video>
  100a85:	48 89 05 fc 2d 00 00 	mov    %rax,0x2dfc(%rip)        # 103888 <currentVideo>
		counterMax = width*height;
  100a8c:	8b 15 fe 2d 00 00    	mov    0x2dfe(%rip),%edx        # 103890 <width>
  100a92:	8b 05 fc 2d 00 00    	mov    0x2dfc(%rip),%eax        # 103894 <height>
  100a98:	0f af c2             	imul   %edx,%eax
  100a9b:	89 05 2b 36 00 00    	mov    %eax,0x362b(%rip)        # 1040cc <counterMax>
		return 1;
  100aa1:	b8 01 00 00 00       	mov    $0x1,%eax
  100aa6:	e9 6a 01 00 00       	jmpq   100c15 <ncSplitConsole+0x265>
	}
	else if (screenQty == 2) {
  100aab:	83 7d ec 02          	cmpl   $0x2,-0x14(%rbp)
  100aaf:	75 4a                	jne    100afb <ncSplitConsole+0x14b>
		shift = 0;
  100ab1:	c7 05 09 36 00 00 00 	movl   $0x0,0x3609(%rip)        # 1040c4 <shift>
  100ab8:	00 00 00 
		width = WIDTH;
  100abb:	c7 05 cb 2d 00 00 50 	movl   $0x50,0x2dcb(%rip)        # 103890 <width>
  100ac2:	00 00 00 
		height = H_HEIGHT;
  100ac5:	c7 05 c5 2d 00 00 0c 	movl   $0xc,0x2dc5(%rip)        # 103894 <height>
  100acc:	00 00 00 
		video = screenNum == 0 ? VIDEO_PTR : VIDEO_PTR + WIDTH*2*(H_HEIGHT+1);
  100acf:	83 7d e8 00          	cmpl   $0x0,-0x18(%rbp)
  100ad3:	75 07                	jne    100adc <ncSplitConsole+0x12c>
  100ad5:	b8 fe 7f 0b 00       	mov    $0xb7ffe,%eax
  100ada:	eb 05                	jmp    100ae1 <ncSplitConsole+0x131>
  100adc:	b8 1e 88 0b 00       	mov    $0xb881e,%eax
  100ae1:	48 89 05 98 2d 00 00 	mov    %rax,0x2d98(%rip)        # 103880 <video>
		currentVideo = video;
  100ae8:	48 8b 05 91 2d 00 00 	mov    0x2d91(%rip),%rax        # 103880 <video>
  100aef:	48 89 05 92 2d 00 00 	mov    %rax,0x2d92(%rip)        # 103888 <currentVideo>
  100af6:	e9 a9 00 00 00       	jmpq   100ba4 <ncSplitConsole+0x1f4>
	}
	else if (screenQty == 4) {
  100afb:	83 7d ec 04          	cmpl   $0x4,-0x14(%rbp)
  100aff:	0f 85 9f 00 00 00    	jne    100ba4 <ncSplitConsole+0x1f4>
		width = (screenNum == 0 || screenNum == 2) ? H_WIDTH1 : H_WIDTH2;
  100b05:	83 7d e8 00          	cmpl   $0x0,-0x18(%rbp)
  100b09:	74 06                	je     100b11 <ncSplitConsole+0x161>
  100b0b:	83 7d e8 02          	cmpl   $0x2,-0x18(%rbp)
  100b0f:	75 07                	jne    100b18 <ncSplitConsole+0x168>
  100b11:	b8 27 00 00 00       	mov    $0x27,%eax
  100b16:	eb 05                	jmp    100b1d <ncSplitConsole+0x16d>
  100b18:	b8 28 00 00 00       	mov    $0x28,%eax
  100b1d:	89 05 6d 2d 00 00    	mov    %eax,0x2d6d(%rip)        # 103890 <width>
		height = H_HEIGHT;
  100b23:	c7 05 67 2d 00 00 0c 	movl   $0xc,0x2d67(%rip)        # 103894 <height>
  100b2a:	00 00 00 
		shift = (screenNum == 0 || screenNum == 2) ? (H_WIDTH2+1)*2 : (H_WIDTH1+1)*2;
  100b2d:	83 7d e8 00          	cmpl   $0x0,-0x18(%rbp)
  100b31:	74 06                	je     100b39 <ncSplitConsole+0x189>
  100b33:	83 7d e8 02          	cmpl   $0x2,-0x18(%rbp)
  100b37:	75 07                	jne    100b40 <ncSplitConsole+0x190>
  100b39:	b8 52 00 00 00       	mov    $0x52,%eax
  100b3e:	eb 05                	jmp    100b45 <ncSplitConsole+0x195>
  100b40:	b8 50 00 00 00       	mov    $0x50,%eax
  100b45:	89 05 79 35 00 00    	mov    %eax,0x3579(%rip)        # 1040c4 <shift>
		video = (screenNum == 0 || screenNum == 1) ? VIDEO_PTR : VIDEO_PTR + WIDTH*2*(H_HEIGHT+1);
  100b4b:	83 7d e8 00          	cmpl   $0x0,-0x18(%rbp)
  100b4f:	74 06                	je     100b57 <ncSplitConsole+0x1a7>
  100b51:	83 7d e8 01          	cmpl   $0x1,-0x18(%rbp)
  100b55:	75 07                	jne    100b5e <ncSplitConsole+0x1ae>
  100b57:	b8 fe 7f 0b 00       	mov    $0xb7ffe,%eax
  100b5c:	eb 05                	jmp    100b63 <ncSplitConsole+0x1b3>
  100b5e:	b8 1e 88 0b 00       	mov    $0xb881e,%eax
  100b63:	48 89 05 16 2d 00 00 	mov    %rax,0x2d16(%rip)        # 103880 <video>
		video += (screenNum == 1 || screenNum == 3) ? shift : 0;
  100b6a:	48 8b 05 0f 2d 00 00 	mov    0x2d0f(%rip),%rax        # 103880 <video>
  100b71:	83 7d e8 01          	cmpl   $0x1,-0x18(%rbp)
  100b75:	74 06                	je     100b7d <ncSplitConsole+0x1cd>
  100b77:	83 7d e8 03          	cmpl   $0x3,-0x18(%rbp)
  100b7b:	75 0a                	jne    100b87 <ncSplitConsole+0x1d7>
  100b7d:	8b 15 41 35 00 00    	mov    0x3541(%rip),%edx        # 1040c4 <shift>
  100b83:	89 d2                	mov    %edx,%edx
  100b85:	eb 05                	jmp    100b8c <ncSplitConsole+0x1dc>
  100b87:	ba 00 00 00 00       	mov    $0x0,%edx
  100b8c:	48 01 d0             	add    %rdx,%rax
  100b8f:	48 89 05 ea 2c 00 00 	mov    %rax,0x2cea(%rip)        # 103880 <video>
		currentVideo = video;
  100b96:	48 8b 05 e3 2c 00 00 	mov    0x2ce3(%rip),%rax        # 103880 <video>
  100b9d:	48 89 05 e4 2c 00 00 	mov    %rax,0x2ce4(%rip)        # 103888 <currentVideo>
	}
	uint8_t * ptr;
	if (screenQty == 4) {
  100ba4:	83 7d ec 04          	cmpl   $0x4,-0x14(%rbp)
  100ba8:	75 2a                	jne    100bd4 <ncSplitConsole+0x224>
		ptr = VIDEO_PTR + 2 + (H_WIDTH1)*2;
  100baa:	48 c7 45 f8 4e 80 0b 	movq   $0xb804e,-0x8(%rbp)
  100bb1:	00 
		for(int i=0 ; i<HEIGHT ; i++) {
  100bb2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  100bb9:	eb 13                	jmp    100bce <ncSplitConsole+0x21e>
		(*ptr) = '|';
  100bbb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  100bbf:	c6 00 7c             	movb   $0x7c,(%rax)
		ptr+=WIDTH*2;
  100bc2:	48 81 45 f8 a0 00 00 	addq   $0xa0,-0x8(%rbp)
  100bc9:	00 
		for(int i=0 ; i<HEIGHT ; i++) {
  100bca:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  100bce:	83 7d f4 18          	cmpl   $0x18,-0xc(%rbp)
  100bd2:	7e e7                	jle    100bbb <ncSplitConsole+0x20b>
	}
	}
	ptr = VIDEO_PTR + 2 + WIDTH*2*H_HEIGHT;
  100bd4:	48 c7 45 f8 80 87 0b 	movq   $0xb8780,-0x8(%rbp)
  100bdb:	00 
	for(int i=0 ; i<80 ; i++) {
  100bdc:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%rbp)
  100be3:	eb 10                	jmp    100bf5 <ncSplitConsole+0x245>
		(*ptr) = '-';
  100be5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  100be9:	c6 00 2d             	movb   $0x2d,(%rax)
		ptr+=2;
  100bec:	48 83 45 f8 02       	addq   $0x2,-0x8(%rbp)
	for(int i=0 ; i<80 ; i++) {
  100bf1:	83 45 f0 01          	addl   $0x1,-0x10(%rbp)
  100bf5:	83 7d f0 4f          	cmpl   $0x4f,-0x10(%rbp)
  100bf9:	7e ea                	jle    100be5 <ncSplitConsole+0x235>
	}
	counterMax = width*height;
  100bfb:	8b 15 8f 2c 00 00    	mov    0x2c8f(%rip),%edx        # 103890 <width>
  100c01:	8b 05 8d 2c 00 00    	mov    0x2c8d(%rip),%eax        # 103894 <height>
  100c07:	0f af c2             	imul   %edx,%eax
  100c0a:	89 05 bc 34 00 00    	mov    %eax,0x34bc(%rip)        # 1040cc <counterMax>
	return 1;
  100c10:	b8 01 00 00 00       	mov    $0x1,%eax
}
  100c15:	c9                   	leaveq 
  100c16:	c3                   	retq   

0000000000100c17 <advancePtr>:

int advancePtr() {
  100c17:	55                   	push   %rbp
  100c18:	48 89 e5             	mov    %rsp,%rbp
	if (position >= width*height)
  100c1b:	8b 15 6f 2c 00 00    	mov    0x2c6f(%rip),%edx        # 103890 <width>
  100c21:	8b 05 6d 2c 00 00    	mov    0x2c6d(%rip),%eax        # 103894 <height>
  100c27:	0f af d0             	imul   %eax,%edx
  100c2a:	8b 05 98 34 00 00    	mov    0x3498(%rip),%eax        # 1040c8 <position>
  100c30:	39 c2                	cmp    %eax,%edx
  100c32:	77 07                	ja     100c3b <advancePtr+0x24>
		return 0;
  100c34:	b8 00 00 00 00       	mov    $0x0,%eax
  100c39:	eb 63                	jmp    100c9e <advancePtr+0x87>

	if (position>1 && position % width == 0) {
  100c3b:	8b 05 87 34 00 00    	mov    0x3487(%rip),%eax        # 1040c8 <position>
  100c41:	83 f8 01             	cmp    $0x1,%eax
  100c44:	76 32                	jbe    100c78 <advancePtr+0x61>
  100c46:	8b 05 7c 34 00 00    	mov    0x347c(%rip),%eax        # 1040c8 <position>
  100c4c:	8b 0d 3e 2c 00 00    	mov    0x2c3e(%rip),%ecx        # 103890 <width>
  100c52:	ba 00 00 00 00       	mov    $0x0,%edx
  100c57:	f7 f1                	div    %ecx
  100c59:	89 d0                	mov    %edx,%eax
  100c5b:	85 c0                	test   %eax,%eax
  100c5d:	75 19                	jne    100c78 <advancePtr+0x61>
		currentVideo += shift;
  100c5f:	48 8b 05 22 2c 00 00 	mov    0x2c22(%rip),%rax        # 103888 <currentVideo>
  100c66:	8b 15 58 34 00 00    	mov    0x3458(%rip),%edx        # 1040c4 <shift>
  100c6c:	89 d2                	mov    %edx,%edx
  100c6e:	48 01 d0             	add    %rdx,%rax
  100c71:	48 89 05 10 2c 00 00 	mov    %rax,0x2c10(%rip)        # 103888 <currentVideo>
	}
	position++;
  100c78:	8b 05 4a 34 00 00    	mov    0x344a(%rip),%eax        # 1040c8 <position>
  100c7e:	83 c0 01             	add    $0x1,%eax
  100c81:	89 05 41 34 00 00    	mov    %eax,0x3441(%rip)        # 1040c8 <position>
	currentVideo += 2;
  100c87:	48 8b 05 fa 2b 00 00 	mov    0x2bfa(%rip),%rax        # 103888 <currentVideo>
  100c8e:	48 83 c0 02          	add    $0x2,%rax
  100c92:	48 89 05 ef 2b 00 00 	mov    %rax,0x2bef(%rip)        # 103888 <currentVideo>
	return 1;
  100c99:	b8 01 00 00 00       	mov    $0x1,%eax
}
  100c9e:	5d                   	pop    %rbp
  100c9f:	c3                   	retq   

0000000000100ca0 <retreatPtr>:

// currentVideo apunta a la posicion ultima posicion escrita
// position apunta a la posicion del puntero dentro de la pantalla (arranca de uno. Si es cero es porque no se escribio nada)

int retreatPtr() {
  100ca0:	55                   	push   %rbp
  100ca1:	48 89 e5             	mov    %rsp,%rbp
	if (position < 1)
  100ca4:	8b 05 1e 34 00 00    	mov    0x341e(%rip),%eax        # 1040c8 <position>
  100caa:	85 c0                	test   %eax,%eax
  100cac:	75 0a                	jne    100cb8 <retreatPtr+0x18>
		return 0;
  100cae:	b8 00 00 00 00       	mov    $0x0,%eax
  100cb3:	e9 85 00 00 00       	jmpq   100d3d <retreatPtr+0x9d>
	if (position == 1) {
  100cb8:	8b 05 0a 34 00 00    	mov    0x340a(%rip),%eax        # 1040c8 <position>
  100cbe:	83 f8 01             	cmp    $0x1,%eax
  100cc1:	75 1f                	jne    100ce2 <retreatPtr+0x42>
		currentVideo = video;
  100cc3:	48 8b 05 b6 2b 00 00 	mov    0x2bb6(%rip),%rax        # 103880 <video>
  100cca:	48 89 05 b7 2b 00 00 	mov    %rax,0x2bb7(%rip)        # 103888 <currentVideo>
		position = 0;
  100cd1:	c7 05 ed 33 00 00 00 	movl   $0x0,0x33ed(%rip)        # 1040c8 <position>
  100cd8:	00 00 00 
		return 1;
  100cdb:	b8 01 00 00 00       	mov    $0x1,%eax
  100ce0:	eb 5b                	jmp    100d3d <retreatPtr+0x9d>
	}	

	position--;
  100ce2:	8b 05 e0 33 00 00    	mov    0x33e0(%rip),%eax        # 1040c8 <position>
  100ce8:	83 e8 01             	sub    $0x1,%eax
  100ceb:	89 05 d7 33 00 00    	mov    %eax,0x33d7(%rip)        # 1040c8 <position>

	if (position % width == 0) {
  100cf1:	8b 05 d1 33 00 00    	mov    0x33d1(%rip),%eax        # 1040c8 <position>
  100cf7:	8b 0d 93 2b 00 00    	mov    0x2b93(%rip),%ecx        # 103890 <width>
  100cfd:	ba 00 00 00 00       	mov    $0x0,%edx
  100d02:	f7 f1                	div    %ecx
  100d04:	89 d0                	mov    %edx,%eax
  100d06:	85 c0                	test   %eax,%eax
  100d08:	75 1c                	jne    100d26 <retreatPtr+0x86>
		currentVideo -= shift;
  100d0a:	48 8b 05 77 2b 00 00 	mov    0x2b77(%rip),%rax        # 103888 <currentVideo>
  100d11:	8b 15 ad 33 00 00    	mov    0x33ad(%rip),%edx        # 1040c4 <shift>
  100d17:	89 d2                	mov    %edx,%edx
  100d19:	48 f7 da             	neg    %rdx
  100d1c:	48 01 d0             	add    %rdx,%rax
  100d1f:	48 89 05 62 2b 00 00 	mov    %rax,0x2b62(%rip)        # 103888 <currentVideo>
	}
	
	currentVideo -= 2;
  100d26:	48 8b 05 5b 2b 00 00 	mov    0x2b5b(%rip),%rax        # 103888 <currentVideo>
  100d2d:	48 83 e8 02          	sub    $0x2,%rax
  100d31:	48 89 05 50 2b 00 00 	mov    %rax,0x2b50(%rip)        # 103888 <currentVideo>
	return 1;
  100d38:	b8 01 00 00 00       	mov    $0x1,%eax
}
  100d3d:	5d                   	pop    %rbp
  100d3e:	c3                   	retq   

0000000000100d3f <ncChangeScreen>:

int ncChangeScreen(int screenNum) {
  100d3f:	55                   	push   %rbp
  100d40:	48 89 e5             	mov    %rsp,%rbp
  100d43:	48 83 ec 28          	sub    $0x28,%rsp
  100d47:	89 7d dc             	mov    %edi,-0x24(%rbp)
	if (screenNum >= screens)
  100d4a:	8b 55 dc             	mov    -0x24(%rbp),%edx
  100d4d:	8b 05 45 2b 00 00    	mov    0x2b45(%rip),%eax        # 103898 <screens>
  100d53:	39 c2                	cmp    %eax,%edx
  100d55:	72 0a                	jb     100d61 <ncChangeScreen+0x22>
		return -1;
  100d57:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  100d5c:	e9 79 02 00 00       	jmpq   100fda <ncChangeScreen+0x29b>
	if (screenNum == screen)
  100d61:	8b 55 dc             	mov    -0x24(%rbp),%edx
  100d64:	8b 05 56 33 00 00    	mov    0x3356(%rip),%eax        # 1040c0 <screen>
  100d6a:	39 c2                	cmp    %eax,%edx
  100d6c:	75 0a                	jne    100d78 <ncChangeScreen+0x39>
		return 1;
  100d6e:	b8 01 00 00 00       	mov    $0x1,%eax
  100d73:	e9 62 02 00 00       	jmpq   100fda <ncChangeScreen+0x29b>
	
	if (screens == 1) {
  100d78:	8b 05 1a 2b 00 00    	mov    0x2b1a(%rip),%eax        # 103898 <screens>
  100d7e:	83 f8 01             	cmp    $0x1,%eax
  100d81:	75 0a                	jne    100d8d <ncChangeScreen+0x4e>
		return 1;
  100d83:	b8 01 00 00 00       	mov    $0x1,%eax
  100d88:	e9 4d 02 00 00       	jmpq   100fda <ncChangeScreen+0x29b>
	}

	else if (screens == 2) {
  100d8d:	8b 05 05 2b 00 00    	mov    0x2b05(%rip),%eax        # 103898 <screens>
  100d93:	83 f8 02             	cmp    $0x2,%eax
  100d96:	0f 85 e6 00 00 00    	jne    100e82 <ncChangeScreen+0x143>
		uint8_t * aux = currentVideo;
  100d9c:	48 8b 05 e5 2a 00 00 	mov    0x2ae5(%rip),%rax        # 103888 <currentVideo>
  100da3:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		int auxPos = position;
  100da7:	8b 05 1b 33 00 00    	mov    0x331b(%rip),%eax        # 1040c8 <position>
  100dad:	89 45 f4             	mov    %eax,-0xc(%rbp)
		shift = 0;
  100db0:	c7 05 0a 33 00 00 00 	movl   $0x0,0x330a(%rip)        # 1040c4 <shift>
  100db7:	00 00 00 
		width = WIDTH;
  100dba:	c7 05 cc 2a 00 00 50 	movl   $0x50,0x2acc(%rip)        # 103890 <width>
  100dc1:	00 00 00 
		height = H_HEIGHT;
  100dc4:	c7 05 c6 2a 00 00 0c 	movl   $0xc,0x2ac6(%rip)        # 103894 <height>
  100dcb:	00 00 00 
		video = screenNum == 0 ? VIDEO_PTR : VIDEO_PTR + WIDTH*2*(H_HEIGHT+1);
  100dce:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  100dd2:	75 07                	jne    100ddb <ncChangeScreen+0x9c>
  100dd4:	b8 fe 7f 0b 00       	mov    $0xb7ffe,%eax
  100dd9:	eb 05                	jmp    100de0 <ncChangeScreen+0xa1>
  100ddb:	b8 1e 88 0b 00       	mov    $0xb881e,%eax
  100de0:	48 89 05 99 2a 00 00 	mov    %rax,0x2a99(%rip)        # 103880 <video>
		
		if (twoScreensAux[screenNum].ptr != 0) {
  100de7:	8b 45 dc             	mov    -0x24(%rbp),%eax
  100dea:	48 98                	cltq   
  100dec:	48 c1 e0 04          	shl    $0x4,%rax
  100df0:	48 05 40 40 10 00    	add    $0x104040,%rax
  100df6:	48 8b 40 08          	mov    0x8(%rax),%rax
  100dfa:	48 85 c0             	test   %rax,%rax
  100dfd:	74 33                	je     100e32 <ncChangeScreen+0xf3>
			currentVideo = twoScreensAux[screenNum].ptr;
  100dff:	8b 45 dc             	mov    -0x24(%rbp),%eax
  100e02:	48 98                	cltq   
  100e04:	48 c1 e0 04          	shl    $0x4,%rax
  100e08:	48 05 40 40 10 00    	add    $0x104040,%rax
  100e0e:	48 8b 40 08          	mov    0x8(%rax),%rax
  100e12:	48 89 05 6f 2a 00 00 	mov    %rax,0x2a6f(%rip)        # 103888 <currentVideo>
			position = twoScreensAux[screenNum].position;
  100e19:	8b 45 dc             	mov    -0x24(%rbp),%eax
  100e1c:	48 98                	cltq   
  100e1e:	48 c1 e0 04          	shl    $0x4,%rax
  100e22:	48 05 40 40 10 00    	add    $0x104040,%rax
  100e28:	8b 00                	mov    (%rax),%eax
  100e2a:	89 05 98 32 00 00    	mov    %eax,0x3298(%rip)        # 1040c8 <position>
  100e30:	eb 18                	jmp    100e4a <ncChangeScreen+0x10b>
		}
		else {
			currentVideo = video;
  100e32:	48 8b 05 47 2a 00 00 	mov    0x2a47(%rip),%rax        # 103880 <video>
  100e39:	48 89 05 48 2a 00 00 	mov    %rax,0x2a48(%rip)        # 103888 <currentVideo>
			position = 0;
  100e40:	c7 05 7e 32 00 00 00 	movl   $0x0,0x327e(%rip)        # 1040c8 <position>
  100e47:	00 00 00 
		}
		twoScreensAux[screen].ptr = aux;
  100e4a:	8b 05 70 32 00 00    	mov    0x3270(%rip),%eax        # 1040c0 <screen>
  100e50:	89 c0                	mov    %eax,%eax
  100e52:	48 c1 e0 04          	shl    $0x4,%rax
  100e56:	48 8d 90 40 40 10 00 	lea    0x104040(%rax),%rdx
  100e5d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  100e61:	48 89 42 08          	mov    %rax,0x8(%rdx)
		twoScreensAux[screen].position = auxPos;
  100e65:	8b 05 55 32 00 00    	mov    0x3255(%rip),%eax        # 1040c0 <screen>
  100e6b:	89 c0                	mov    %eax,%eax
  100e6d:	48 c1 e0 04          	shl    $0x4,%rax
  100e71:	48 8d 90 40 40 10 00 	lea    0x104040(%rax),%rdx
  100e78:	8b 45 f4             	mov    -0xc(%rbp),%eax
  100e7b:	89 02                	mov    %eax,(%rdx)
  100e7d:	e9 4a 01 00 00       	jmpq   100fcc <ncChangeScreen+0x28d>
	}
	else if (screens == 4) {
  100e82:	8b 05 10 2a 00 00    	mov    0x2a10(%rip),%eax        # 103898 <screens>
  100e88:	83 f8 04             	cmp    $0x4,%eax
  100e8b:	0f 85 3b 01 00 00    	jne    100fcc <ncChangeScreen+0x28d>
		uint8_t * aux = currentVideo;
  100e91:	48 8b 05 f0 29 00 00 	mov    0x29f0(%rip),%rax        # 103888 <currentVideo>
  100e98:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
		int auxPos = position;
  100e9c:	8b 05 26 32 00 00    	mov    0x3226(%rip),%eax        # 1040c8 <position>
  100ea2:	89 45 e4             	mov    %eax,-0x1c(%rbp)
		width = (screenNum == 0 || screenNum == 2) ? H_WIDTH1 : H_WIDTH2;
  100ea5:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  100ea9:	74 06                	je     100eb1 <ncChangeScreen+0x172>
  100eab:	83 7d dc 02          	cmpl   $0x2,-0x24(%rbp)
  100eaf:	75 07                	jne    100eb8 <ncChangeScreen+0x179>
  100eb1:	b8 27 00 00 00       	mov    $0x27,%eax
  100eb6:	eb 05                	jmp    100ebd <ncChangeScreen+0x17e>
  100eb8:	b8 28 00 00 00       	mov    $0x28,%eax
  100ebd:	89 05 cd 29 00 00    	mov    %eax,0x29cd(%rip)        # 103890 <width>
		height = H_HEIGHT;
  100ec3:	c7 05 c7 29 00 00 0c 	movl   $0xc,0x29c7(%rip)        # 103894 <height>
  100eca:	00 00 00 
		shift = (screenNum == 0 || screenNum == 2) ? (H_WIDTH2+1)*2 : (H_WIDTH1+1)*2;
  100ecd:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  100ed1:	74 06                	je     100ed9 <ncChangeScreen+0x19a>
  100ed3:	83 7d dc 02          	cmpl   $0x2,-0x24(%rbp)
  100ed7:	75 07                	jne    100ee0 <ncChangeScreen+0x1a1>
  100ed9:	b8 52 00 00 00       	mov    $0x52,%eax
  100ede:	eb 05                	jmp    100ee5 <ncChangeScreen+0x1a6>
  100ee0:	b8 50 00 00 00       	mov    $0x50,%eax
  100ee5:	89 05 d9 31 00 00    	mov    %eax,0x31d9(%rip)        # 1040c4 <shift>
		video = (screenNum == 0 || screenNum == 1) ? VIDEO_PTR : VIDEO_PTR + WIDTH*2*(H_HEIGHT+1);
  100eeb:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  100eef:	74 06                	je     100ef7 <ncChangeScreen+0x1b8>
  100ef1:	83 7d dc 01          	cmpl   $0x1,-0x24(%rbp)
  100ef5:	75 07                	jne    100efe <ncChangeScreen+0x1bf>
  100ef7:	b8 fe 7f 0b 00       	mov    $0xb7ffe,%eax
  100efc:	eb 05                	jmp    100f03 <ncChangeScreen+0x1c4>
  100efe:	b8 1e 88 0b 00       	mov    $0xb881e,%eax
  100f03:	48 89 05 76 29 00 00 	mov    %rax,0x2976(%rip)        # 103880 <video>
		video += (screenNum == 1 || screenNum == 3) ? shift : 0;
  100f0a:	48 8b 05 6f 29 00 00 	mov    0x296f(%rip),%rax        # 103880 <video>
  100f11:	83 7d dc 01          	cmpl   $0x1,-0x24(%rbp)
  100f15:	74 06                	je     100f1d <ncChangeScreen+0x1de>
  100f17:	83 7d dc 03          	cmpl   $0x3,-0x24(%rbp)
  100f1b:	75 0a                	jne    100f27 <ncChangeScreen+0x1e8>
  100f1d:	8b 15 a1 31 00 00    	mov    0x31a1(%rip),%edx        # 1040c4 <shift>
  100f23:	89 d2                	mov    %edx,%edx
  100f25:	eb 05                	jmp    100f2c <ncChangeScreen+0x1ed>
  100f27:	ba 00 00 00 00       	mov    $0x0,%edx
  100f2c:	48 01 d0             	add    %rdx,%rax
  100f2f:	48 89 05 4a 29 00 00 	mov    %rax,0x294a(%rip)        # 103880 <video>
		if (fourScreensAux[screenNum].ptr != 0) {
  100f36:	8b 45 dc             	mov    -0x24(%rbp),%eax
  100f39:	48 98                	cltq   
  100f3b:	48 c1 e0 04          	shl    $0x4,%rax
  100f3f:	48 05 80 40 10 00    	add    $0x104080,%rax
  100f45:	48 8b 40 08          	mov    0x8(%rax),%rax
  100f49:	48 85 c0             	test   %rax,%rax
  100f4c:	74 33                	je     100f81 <ncChangeScreen+0x242>
			currentVideo = fourScreensAux[screenNum].ptr;
  100f4e:	8b 45 dc             	mov    -0x24(%rbp),%eax
  100f51:	48 98                	cltq   
  100f53:	48 c1 e0 04          	shl    $0x4,%rax
  100f57:	48 05 80 40 10 00    	add    $0x104080,%rax
  100f5d:	48 8b 40 08          	mov    0x8(%rax),%rax
  100f61:	48 89 05 20 29 00 00 	mov    %rax,0x2920(%rip)        # 103888 <currentVideo>
			position = fourScreensAux[screenNum].position;
  100f68:	8b 45 dc             	mov    -0x24(%rbp),%eax
  100f6b:	48 98                	cltq   
  100f6d:	48 c1 e0 04          	shl    $0x4,%rax
  100f71:	48 05 80 40 10 00    	add    $0x104080,%rax
  100f77:	8b 00                	mov    (%rax),%eax
  100f79:	89 05 49 31 00 00    	mov    %eax,0x3149(%rip)        # 1040c8 <position>
  100f7f:	eb 18                	jmp    100f99 <ncChangeScreen+0x25a>
		}
		else {
			currentVideo = video;
  100f81:	48 8b 05 f8 28 00 00 	mov    0x28f8(%rip),%rax        # 103880 <video>
  100f88:	48 89 05 f9 28 00 00 	mov    %rax,0x28f9(%rip)        # 103888 <currentVideo>
			position = 0;
  100f8f:	c7 05 2f 31 00 00 00 	movl   $0x0,0x312f(%rip)        # 1040c8 <position>
  100f96:	00 00 00 
		}
		fourScreensAux[screen].ptr = aux;
  100f99:	8b 05 21 31 00 00    	mov    0x3121(%rip),%eax        # 1040c0 <screen>
  100f9f:	89 c0                	mov    %eax,%eax
  100fa1:	48 c1 e0 04          	shl    $0x4,%rax
  100fa5:	48 8d 90 80 40 10 00 	lea    0x104080(%rax),%rdx
  100fac:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  100fb0:	48 89 42 08          	mov    %rax,0x8(%rdx)
		fourScreensAux[screen].position = auxPos;
  100fb4:	8b 05 06 31 00 00    	mov    0x3106(%rip),%eax        # 1040c0 <screen>
  100fba:	89 c0                	mov    %eax,%eax
  100fbc:	48 c1 e0 04          	shl    $0x4,%rax
  100fc0:	48 8d 90 80 40 10 00 	lea    0x104080(%rax),%rdx
  100fc7:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  100fca:	89 02                	mov    %eax,(%rdx)
	}
	screen = screenNum;
  100fcc:	8b 45 dc             	mov    -0x24(%rbp),%eax
  100fcf:	89 05 eb 30 00 00    	mov    %eax,0x30eb(%rip)        # 1040c0 <screen>
	return 1;
  100fd5:	b8 01 00 00 00       	mov    $0x1,%eax
}
  100fda:	c9                   	leaveq 
  100fdb:	c3                   	retq   

0000000000100fdc <ncPrint>:

void ncPrint(const char * string)
{
  100fdc:	55                   	push   %rbp
  100fdd:	48 89 e5             	mov    %rsp,%rbp
  100fe0:	48 83 ec 20          	sub    $0x20,%rsp
  100fe4:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int i;

	for (i = 0; string[i] != 0; i++) {
  100fe8:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  100fef:	eb 23                	jmp    101014 <ncPrint+0x38>
		ncPrintChar(string[i],DEFAULT_COLOR);
  100ff1:	8b 45 fc             	mov    -0x4(%rbp),%eax
  100ff4:	48 63 d0             	movslq %eax,%rdx
  100ff7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  100ffb:	48 01 d0             	add    %rdx,%rax
  100ffe:	0f b6 00             	movzbl (%rax),%eax
  101001:	0f be c0             	movsbl %al,%eax
  101004:	be 07 00 00 00       	mov    $0x7,%esi
  101009:	89 c7                	mov    %eax,%edi
  10100b:	e8 1a 00 00 00       	callq  10102a <ncPrintChar>
	for (i = 0; string[i] != 0; i++) {
  101010:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  101014:	8b 45 fc             	mov    -0x4(%rbp),%eax
  101017:	48 63 d0             	movslq %eax,%rdx
  10101a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  10101e:	48 01 d0             	add    %rdx,%rax
  101021:	0f b6 00             	movzbl (%rax),%eax
  101024:	84 c0                	test   %al,%al
  101026:	75 c9                	jne    100ff1 <ncPrint+0x15>
	}
		
}
  101028:	c9                   	leaveq 
  101029:	c3                   	retq   

000000000010102a <ncPrintChar>:

void ncPrintChar(char character, char color)
{	if (!advancePtr())
  10102a:	55                   	push   %rbp
  10102b:	48 89 e5             	mov    %rsp,%rbp
  10102e:	48 83 ec 08          	sub    $0x8,%rsp
  101032:	89 fa                	mov    %edi,%edx
  101034:	89 f0                	mov    %esi,%eax
  101036:	88 55 fc             	mov    %dl,-0x4(%rbp)
  101039:	88 45 f8             	mov    %al,-0x8(%rbp)
  10103c:	b8 00 00 00 00       	mov    $0x0,%eax
  101041:	e8 d1 fb ff ff       	callq  100c17 <advancePtr>
  101046:	85 c0                	test   %eax,%eax
  101048:	75 02                	jne    10104c <ncPrintChar+0x22>
		return;
  10104a:	eb 1e                	jmp    10106a <ncPrintChar+0x40>

	*currentVideo = character;
  10104c:	48 8b 05 35 28 00 00 	mov    0x2835(%rip),%rax        # 103888 <currentVideo>
  101053:	0f b6 55 fc          	movzbl -0x4(%rbp),%edx
  101057:	88 10                	mov    %dl,(%rax)
	*(currentVideo+1) = color;
  101059:	48 8b 05 28 28 00 00 	mov    0x2828(%rip),%rax        # 103888 <currentVideo>
  101060:	48 8d 50 01          	lea    0x1(%rax),%rdx
  101064:	0f b6 45 f8          	movzbl -0x8(%rbp),%eax
  101068:	88 02                	mov    %al,(%rdx)
}
  10106a:	c9                   	leaveq 
  10106b:	c3                   	retq   

000000000010106c <ncNewline>:


void ncNewline()
{
  10106c:	55                   	push   %rbp
  10106d:	48 89 e5             	mov    %rsp,%rbp
	if (position >= counterMax)
  101070:	8b 15 52 30 00 00    	mov    0x3052(%rip),%edx        # 1040c8 <position>
  101076:	8b 05 50 30 00 00    	mov    0x3050(%rip),%eax        # 1040cc <counterMax>
  10107c:	39 c2                	cmp    %eax,%edx
  10107e:	72 02                	jb     101082 <ncNewline+0x16>
		return;
  101080:	eb 28                	jmp    1010aa <ncNewline+0x3e>
	do
	{
		ncPrintChar(' ',DEFAULT_COLOR);
  101082:	be 07 00 00 00       	mov    $0x7,%esi
  101087:	bf 20 00 00 00       	mov    $0x20,%edi
  10108c:	e8 99 ff ff ff       	callq  10102a <ncPrintChar>
	}
	while((position) % (width) != 0);
  101091:	8b 05 31 30 00 00    	mov    0x3031(%rip),%eax        # 1040c8 <position>
  101097:	8b 0d f3 27 00 00    	mov    0x27f3(%rip),%ecx        # 103890 <width>
  10109d:	ba 00 00 00 00       	mov    $0x0,%edx
  1010a2:	f7 f1                	div    %ecx
  1010a4:	89 d0                	mov    %edx,%eax
  1010a6:	85 c0                	test   %eax,%eax
  1010a8:	75 d8                	jne    101082 <ncNewline+0x16>
}
  1010aa:	5d                   	pop    %rbp
  1010ab:	c3                   	retq   

00000000001010ac <ncDelete>:

void ncDelete()
{
  1010ac:	55                   	push   %rbp
  1010ad:	48 89 e5             	mov    %rsp,%rbp
	*currentVideo = ' ';
  1010b0:	48 8b 05 d1 27 00 00 	mov    0x27d1(%rip),%rax        # 103888 <currentVideo>
  1010b7:	c6 00 20             	movb   $0x20,(%rax)

	retreatPtr();
  1010ba:	b8 00 00 00 00       	mov    $0x0,%eax
  1010bf:	e8 dc fb ff ff       	callq  100ca0 <retreatPtr>
	
	
}
  1010c4:	5d                   	pop    %rbp
  1010c5:	c3                   	retq   

00000000001010c6 <ncClearLine>:

void ncClearLine() {
  1010c6:	55                   	push   %rbp
  1010c7:	48 89 e5             	mov    %rsp,%rbp
	while (position > 0 && (position % width !=0 || position == height*width))
  1010ca:	eb 0a                	jmp    1010d6 <ncClearLine+0x10>
		ncDelete();
  1010cc:	b8 00 00 00 00       	mov    $0x0,%eax
  1010d1:	e8 d6 ff ff ff       	callq  1010ac <ncDelete>
	while (position > 0 && (position % width !=0 || position == height*width))
  1010d6:	8b 05 ec 2f 00 00    	mov    0x2fec(%rip),%eax        # 1040c8 <position>
  1010dc:	85 c0                	test   %eax,%eax
  1010de:	74 32                	je     101112 <ncClearLine+0x4c>
  1010e0:	8b 05 e2 2f 00 00    	mov    0x2fe2(%rip),%eax        # 1040c8 <position>
  1010e6:	8b 0d a4 27 00 00    	mov    0x27a4(%rip),%ecx        # 103890 <width>
  1010ec:	ba 00 00 00 00       	mov    $0x0,%edx
  1010f1:	f7 f1                	div    %ecx
  1010f3:	89 d0                	mov    %edx,%eax
  1010f5:	85 c0                	test   %eax,%eax
  1010f7:	75 d3                	jne    1010cc <ncClearLine+0x6>
  1010f9:	8b 15 95 27 00 00    	mov    0x2795(%rip),%edx        # 103894 <height>
  1010ff:	8b 05 8b 27 00 00    	mov    0x278b(%rip),%eax        # 103890 <width>
  101105:	0f af d0             	imul   %eax,%edx
  101108:	8b 05 ba 2f 00 00    	mov    0x2fba(%rip),%eax        # 1040c8 <position>
  10110e:	39 c2                	cmp    %eax,%edx
  101110:	74 ba                	je     1010cc <ncClearLine+0x6>
}
  101112:	5d                   	pop    %rbp
  101113:	c3                   	retq   

0000000000101114 <ncPrintDec>:



void ncPrintDec(uint64_t value)
{
  101114:	55                   	push   %rbp
  101115:	48 89 e5             	mov    %rsp,%rbp
  101118:	48 83 ec 10          	sub    $0x10,%rsp
  10111c:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	ncPrintBase(value, 10);
  101120:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  101124:	be 0a 00 00 00       	mov    $0xa,%esi
  101129:	48 89 c7             	mov    %rax,%rdi
  10112c:	e8 40 00 00 00       	callq  101171 <ncPrintBase>
}
  101131:	c9                   	leaveq 
  101132:	c3                   	retq   

0000000000101133 <ncPrintHex>:

void ncPrintHex(uint64_t value)
{
  101133:	55                   	push   %rbp
  101134:	48 89 e5             	mov    %rsp,%rbp
  101137:	48 83 ec 10          	sub    $0x10,%rsp
  10113b:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	ncPrintBase(value, 16);
  10113f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  101143:	be 10 00 00 00       	mov    $0x10,%esi
  101148:	48 89 c7             	mov    %rax,%rdi
  10114b:	e8 21 00 00 00       	callq  101171 <ncPrintBase>
}
  101150:	c9                   	leaveq 
  101151:	c3                   	retq   

0000000000101152 <ncPrintBin>:

void ncPrintBin(uint64_t value)
{
  101152:	55                   	push   %rbp
  101153:	48 89 e5             	mov    %rsp,%rbp
  101156:	48 83 ec 10          	sub    $0x10,%rsp
  10115a:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	ncPrintBase(value, 2);
  10115e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  101162:	be 02 00 00 00       	mov    $0x2,%esi
  101167:	48 89 c7             	mov    %rax,%rdi
  10116a:	e8 02 00 00 00       	callq  101171 <ncPrintBase>
}
  10116f:	c9                   	leaveq 
  101170:	c3                   	retq   

0000000000101171 <ncPrintBase>:

void ncPrintBase(uint64_t value, uint32_t base)
{
  101171:	55                   	push   %rbp
  101172:	48 89 e5             	mov    %rsp,%rbp
  101175:	48 83 ec 10          	sub    $0x10,%rsp
  101179:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  10117d:	89 75 f4             	mov    %esi,-0xc(%rbp)
    uintToBase(value, buffer, base);
  101180:	8b 55 f4             	mov    -0xc(%rbp),%edx
  101183:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  101187:	be 40 38 10 00       	mov    $0x103840,%esi
  10118c:	48 89 c7             	mov    %rax,%rdi
  10118f:	e8 9f 00 00 00       	callq  101233 <uintToBase>
    ncPrint(buffer);
  101194:	bf 40 38 10 00       	mov    $0x103840,%edi
  101199:	e8 3e fe ff ff       	callq  100fdc <ncPrint>
}
  10119e:	c9                   	leaveq 
  10119f:	c3                   	retq   

00000000001011a0 <ncClear>:
//     ncPrint(" - ");
//     ncPrintTime();
// }

void ncClear()
{
  1011a0:	55                   	push   %rbp
  1011a1:	48 89 e5             	mov    %rsp,%rbp
  1011a4:	48 83 ec 10          	sub    $0x10,%rsp
	uint8_t * ptr = video+2;
  1011a8:	48 8b 05 d1 26 00 00 	mov    0x26d1(%rip),%rax        # 103880 <video>
  1011af:	48 83 c0 02          	add    $0x2,%rax
  1011b3:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	for(int i=0 ; i<height*width ; i++) {
  1011b7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  1011be:	eb 43                	jmp    101203 <ncClear+0x63>
		if (i % width  == 0 && i>0)
  1011c0:	8b 45 f4             	mov    -0xc(%rbp),%eax
  1011c3:	8b 0d c7 26 00 00    	mov    0x26c7(%rip),%ecx        # 103890 <width>
  1011c9:	ba 00 00 00 00       	mov    $0x0,%edx
  1011ce:	f7 f1                	div    %ecx
  1011d0:	89 d0                	mov    %edx,%eax
  1011d2:	85 c0                	test   %eax,%eax
  1011d4:	75 12                	jne    1011e8 <ncClear+0x48>
  1011d6:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  1011da:	7e 0c                	jle    1011e8 <ncClear+0x48>
			ptr += shift;
  1011dc:	8b 05 e2 2e 00 00    	mov    0x2ee2(%rip),%eax        # 1040c4 <shift>
  1011e2:	89 c0                	mov    %eax,%eax
  1011e4:	48 01 45 f8          	add    %rax,-0x8(%rbp)
		(*ptr) = ' ';
  1011e8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  1011ec:	c6 00 20             	movb   $0x20,(%rax)
		*(ptr+1) = 7;
  1011ef:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  1011f3:	48 83 c0 01          	add    $0x1,%rax
  1011f7:	c6 00 07             	movb   $0x7,(%rax)
		ptr+=2;
  1011fa:	48 83 45 f8 02       	addq   $0x2,-0x8(%rbp)
	for(int i=0 ; i<height*width ; i++) {
  1011ff:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  101203:	8b 55 f4             	mov    -0xc(%rbp),%edx
  101206:	8b 0d 88 26 00 00    	mov    0x2688(%rip),%ecx        # 103894 <height>
  10120c:	8b 05 7e 26 00 00    	mov    0x267e(%rip),%eax        # 103890 <width>
  101212:	0f af c1             	imul   %ecx,%eax
  101215:	39 c2                	cmp    %eax,%edx
  101217:	72 a7                	jb     1011c0 <ncClear+0x20>
	}
	position = 0;
  101219:	c7 05 a5 2e 00 00 00 	movl   $0x0,0x2ea5(%rip)        # 1040c8 <position>
  101220:	00 00 00 
	currentVideo = video;
  101223:	48 8b 05 56 26 00 00 	mov    0x2656(%rip),%rax        # 103880 <video>
  10122a:	48 89 05 57 26 00 00 	mov    %rax,0x2657(%rip)        # 103888 <currentVideo>
}
  101231:	c9                   	leaveq 
  101232:	c3                   	retq   

0000000000101233 <uintToBase>:

static uint32_t uintToBase(uint64_t value, char * buffer, uint32_t base)
{
  101233:	55                   	push   %rbp
  101234:	48 89 e5             	mov    %rsp,%rbp
  101237:	48 83 ec 48          	sub    $0x48,%rsp
  10123b:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  10123f:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  101243:	89 55 bc             	mov    %edx,-0x44(%rbp)
	char *p = buffer;
  101246:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  10124a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	char *p1, *p2;
	uint32_t digits = 0;
  10124e:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%rbp)

	//Calculate characters for each digit
	do
	{
		uint32_t remainder = value % base;
  101255:	8b 4d bc             	mov    -0x44(%rbp),%ecx
  101258:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  10125c:	ba 00 00 00 00       	mov    $0x0,%edx
  101261:	48 f7 f1             	div    %rcx
  101264:	48 89 d0             	mov    %rdx,%rax
  101267:	89 45 e0             	mov    %eax,-0x20(%rbp)
		*p++ = (remainder < 10) ? remainder + '0' : remainder + 'A' - 10;
  10126a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  10126e:	48 8d 50 01          	lea    0x1(%rax),%rdx
  101272:	48 89 55 f8          	mov    %rdx,-0x8(%rbp)
  101276:	83 7d e0 09          	cmpl   $0x9,-0x20(%rbp)
  10127a:	77 08                	ja     101284 <uintToBase+0x51>
  10127c:	8b 55 e0             	mov    -0x20(%rbp),%edx
  10127f:	83 c2 30             	add    $0x30,%edx
  101282:	eb 06                	jmp    10128a <uintToBase+0x57>
  101284:	8b 55 e0             	mov    -0x20(%rbp),%edx
  101287:	83 c2 37             	add    $0x37,%edx
  10128a:	88 10                	mov    %dl,(%rax)
		digits++;
  10128c:	83 45 e4 01          	addl   $0x1,-0x1c(%rbp)
	}
	while (value /= base);
  101290:	8b 75 bc             	mov    -0x44(%rbp),%esi
  101293:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  101297:	ba 00 00 00 00       	mov    $0x0,%edx
  10129c:	48 f7 f6             	div    %rsi
  10129f:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  1012a3:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  1012a8:	75 ab                	jne    101255 <uintToBase+0x22>

	// Terminate string in buffer.
	*p = 0;
  1012aa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  1012ae:	c6 00 00             	movb   $0x0,(%rax)

	//Reverse string in buffer.
	p1 = buffer;
  1012b1:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  1012b5:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	p2 = p - 1;
  1012b9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  1012bd:	48 83 e8 01          	sub    $0x1,%rax
  1012c1:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	while (p1 < p2)
  1012c5:	eb 2b                	jmp    1012f2 <uintToBase+0xbf>
	{
		char tmp = *p1;
  1012c7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  1012cb:	0f b6 00             	movzbl (%rax),%eax
  1012ce:	88 45 df             	mov    %al,-0x21(%rbp)
		*p1 = *p2;
  1012d1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  1012d5:	0f b6 10             	movzbl (%rax),%edx
  1012d8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  1012dc:	88 10                	mov    %dl,(%rax)
		*p2 = tmp;
  1012de:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  1012e2:	0f b6 55 df          	movzbl -0x21(%rbp),%edx
  1012e6:	88 10                	mov    %dl,(%rax)
		p1++;
  1012e8:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
		p2--;
  1012ed:	48 83 6d e8 01       	subq   $0x1,-0x18(%rbp)
	while (p1 < p2)
  1012f2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  1012f6:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  1012fa:	72 cb                	jb     1012c7 <uintToBase+0x94>
	}

	return digits;
  1012fc:	8b 45 e4             	mov    -0x1c(%rbp),%eax
}
  1012ff:	c9                   	leaveq 
  101300:	c3                   	retq   

0000000000101301 <loadModules>:

static void loadModule(uint8_t ** module, void * targetModuleAddress);
static uint32_t readUint32(uint8_t ** address);

void loadModules(void * payloadStart, void ** targetModuleAddress)
{
  101301:	55                   	push   %rbp
  101302:	48 89 e5             	mov    %rsp,%rbp
  101305:	48 83 ec 20          	sub    $0x20,%rsp
  101309:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  10130d:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	int i;
	uint8_t * currentModule = (uint8_t*)payloadStart;
  101311:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  101315:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	uint32_t moduleCount = readUint32(&currentModule);
  101319:	48 8d 45 f0          	lea    -0x10(%rbp),%rax
  10131d:	48 89 c7             	mov    %rax,%rdi
  101320:	e8 f0 00 00 00       	callq  101415 <readUint32>
  101325:	89 45 f8             	mov    %eax,-0x8(%rbp)

	for (i = 0; i < moduleCount; i++)
  101328:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  10132f:	eb 2a                	jmp    10135b <loadModules+0x5a>
		loadModule(&currentModule, targetModuleAddress[i]);
  101331:	8b 45 fc             	mov    -0x4(%rbp),%eax
  101334:	48 98                	cltq   
  101336:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  10133d:	00 
  10133e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  101342:	48 01 d0             	add    %rdx,%rax
  101345:	48 8b 10             	mov    (%rax),%rdx
  101348:	48 8d 45 f0          	lea    -0x10(%rbp),%rax
  10134c:	48 89 d6             	mov    %rdx,%rsi
  10134f:	48 89 c7             	mov    %rax,%rdi
  101352:	e8 0e 00 00 00       	callq  101365 <loadModule>
	for (i = 0; i < moduleCount; i++)
  101357:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  10135b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  10135e:	3b 45 f8             	cmp    -0x8(%rbp),%eax
  101361:	72 ce                	jb     101331 <loadModules+0x30>
}
  101363:	c9                   	leaveq 
  101364:	c3                   	retq   

0000000000101365 <loadModule>:

static void loadModule(uint8_t ** module, void * targetModuleAddress)
{
  101365:	55                   	push   %rbp
  101366:	48 89 e5             	mov    %rsp,%rbp
  101369:	48 83 ec 20          	sub    $0x20,%rsp
  10136d:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  101371:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	uint32_t moduleSize = readUint32(module);
  101375:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  101379:	48 89 c7             	mov    %rax,%rdi
  10137c:	e8 94 00 00 00       	callq  101415 <readUint32>
  101381:	89 45 fc             	mov    %eax,-0x4(%rbp)

	ncPrint("  Will copy module at 0x");
  101384:	bf 00 20 10 00       	mov    $0x102000,%edi
  101389:	e8 4e fc ff ff       	callq  100fdc <ncPrint>
	ncPrintHex((uint64_t)*module);
  10138e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  101392:	48 8b 00             	mov    (%rax),%rax
  101395:	48 89 c7             	mov    %rax,%rdi
  101398:	e8 96 fd ff ff       	callq  101133 <ncPrintHex>
	ncPrint(" to 0x");
  10139d:	bf 19 20 10 00       	mov    $0x102019,%edi
  1013a2:	e8 35 fc ff ff       	callq  100fdc <ncPrint>
	ncPrintHex((uint64_t)targetModuleAddress);
  1013a7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  1013ab:	48 89 c7             	mov    %rax,%rdi
  1013ae:	e8 80 fd ff ff       	callq  101133 <ncPrintHex>
	ncPrint(" (");
  1013b3:	bf 20 20 10 00       	mov    $0x102020,%edi
  1013b8:	e8 1f fc ff ff       	callq  100fdc <ncPrint>
	ncPrintDec(moduleSize);
  1013bd:	8b 45 fc             	mov    -0x4(%rbp),%eax
  1013c0:	48 89 c7             	mov    %rax,%rdi
  1013c3:	e8 4c fd ff ff       	callq  101114 <ncPrintDec>
	ncPrint(" bytes)");
  1013c8:	bf 23 20 10 00       	mov    $0x102023,%edi
  1013cd:	e8 0a fc ff ff       	callq  100fdc <ncPrint>

	memcpy(targetModuleAddress, *module, moduleSize);
  1013d2:	8b 55 fc             	mov    -0x4(%rbp),%edx
  1013d5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  1013d9:	48 8b 08             	mov    (%rax),%rcx
  1013dc:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  1013e0:	48 89 ce             	mov    %rcx,%rsi
  1013e3:	48 89 c7             	mov    %rax,%rdi
  1013e6:	e8 71 ec ff ff       	callq  10005c <memcpy>
	*module += moduleSize;
  1013eb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  1013ef:	48 8b 10             	mov    (%rax),%rdx
  1013f2:	8b 45 fc             	mov    -0x4(%rbp),%eax
  1013f5:	48 01 c2             	add    %rax,%rdx
  1013f8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  1013fc:	48 89 10             	mov    %rdx,(%rax)

	ncPrint(" [Done]");
  1013ff:	bf 2b 20 10 00       	mov    $0x10202b,%edi
  101404:	e8 d3 fb ff ff       	callq  100fdc <ncPrint>
	ncNewline();
  101409:	b8 00 00 00 00       	mov    $0x0,%eax
  10140e:	e8 59 fc ff ff       	callq  10106c <ncNewline>
}
  101413:	c9                   	leaveq 
  101414:	c3                   	retq   

0000000000101415 <readUint32>:

static uint32_t readUint32(uint8_t ** address)
{
  101415:	55                   	push   %rbp
  101416:	48 89 e5             	mov    %rsp,%rbp
  101419:	48 83 ec 18          	sub    $0x18,%rsp
  10141d:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	uint32_t result = *(uint32_t*)(*address);
  101421:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  101425:	48 8b 00             	mov    (%rax),%rax
  101428:	8b 00                	mov    (%rax),%eax
  10142a:	89 45 fc             	mov    %eax,-0x4(%rbp)
	*address += sizeof(uint32_t);
  10142d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  101431:	48 8b 00             	mov    (%rax),%rax
  101434:	48 8d 50 04          	lea    0x4(%rax),%rdx
  101438:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  10143c:	48 89 10             	mov    %rdx,(%rax)
	return result;
  10143f:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  101442:	c9                   	leaveq 
  101443:	c3                   	retq   

0000000000101444 <load_idt>:

DESCR_INT * idt = (DESCR_INT *) 0;	// IDT de 255 entradas

static void setup_IDT_entry (int index, uint64_t offset);

void load_idt() {
  101444:	55                   	push   %rbp
  101445:	48 89 e5             	mov    %rsp,%rbp
  _cli();
  101448:	e8 de 04 00 00       	callq  10192b <_cli>

  setup_IDT_entry (0x20, (uint64_t)&_irq00Handler); // int 20h (timer tick)
  10144d:	b8 45 19 10 00       	mov    $0x101945,%eax
  101452:	48 89 c6             	mov    %rax,%rsi
  101455:	bf 20 00 00 00       	mov    $0x20,%edi
  10145a:	e8 3f 00 00 00       	callq  10149e <setup_IDT_entry>
   setup_IDT_entry (0x21, (uint64_t)&_irq01Handler); // int 21h (teclado)
  10145f:	b8 83 19 10 00       	mov    $0x101983,%eax
  101464:	48 89 c6             	mov    %rax,%rsi
  101467:	bf 21 00 00 00       	mov    $0x21,%edi
  10146c:	e8 2d 00 00 00       	callq  10149e <setup_IDT_entry>
   setup_IDT_entry(0x80, (uint64_t)&_sysCallHandlerMaster);
  101471:	b8 f0 18 10 00       	mov    $0x1018f0,%eax
  101476:	48 89 c6             	mov    %rax,%rsi
  101479:	bf 80 00 00 00       	mov    $0x80,%edi
  10147e:	e8 1b 00 00 00       	callq  10149e <setup_IDT_entry>
  // setup_IDT_entry(0x00, (uint64_t)&_exception00Handler); // Handler para division por cero.
  // setup_IDT_entry(0x06, (uint64_t)&_exception06Handler); // Handler para operación inválida.

	picMasterMask(0xFC); // irq00 => timer tick (int 20) e irq01 => teclado (int 21) 
  101483:	bf fc 00 00 00       	mov    $0xfc,%edi
  101488:	e8 a2 04 00 00       	callq  10192f <picMasterMask>
	picSlaveMask(0xFF);
  10148d:	bf ff 00 00 00       	mov    $0xff,%edi
  101492:	e8 a3 04 00 00       	callq  10193a <picSlaveMask>
        
	_sti();
  101497:	e8 91 04 00 00       	callq  10192d <_sti>
}
  10149c:	5d                   	pop    %rbp
  10149d:	c3                   	retq   

000000000010149e <setup_IDT_entry>:

static void setup_IDT_entry (int index, uint64_t offset) {
  10149e:	55                   	push   %rbp
  10149f:	48 89 e5             	mov    %rsp,%rbp
  1014a2:	48 83 ec 10          	sub    $0x10,%rsp
  1014a6:	89 7d fc             	mov    %edi,-0x4(%rbp)
  1014a9:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  idt[index].selector = 0x08;
  1014ad:	48 8b 05 1c 2c 00 00 	mov    0x2c1c(%rip),%rax        # 1040d0 <idt>
  1014b4:	8b 55 fc             	mov    -0x4(%rbp),%edx
  1014b7:	48 63 d2             	movslq %edx,%rdx
  1014ba:	48 c1 e2 04          	shl    $0x4,%rdx
  1014be:	48 01 d0             	add    %rdx,%rax
  1014c1:	66 c7 40 02 08 00    	movw   $0x8,0x2(%rax)
  idt[index].offset_l = offset & 0xFFFF;
  1014c7:	48 8b 05 02 2c 00 00 	mov    0x2c02(%rip),%rax        # 1040d0 <idt>
  1014ce:	8b 55 fc             	mov    -0x4(%rbp),%edx
  1014d1:	48 63 d2             	movslq %edx,%rdx
  1014d4:	48 c1 e2 04          	shl    $0x4,%rdx
  1014d8:	48 01 d0             	add    %rdx,%rax
  1014db:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  1014df:	66 89 10             	mov    %dx,(%rax)
  idt[index].offset_m = (offset >> 16) & 0xFFFF;
  1014e2:	48 8b 05 e7 2b 00 00 	mov    0x2be7(%rip),%rax        # 1040d0 <idt>
  1014e9:	8b 55 fc             	mov    -0x4(%rbp),%edx
  1014ec:	48 63 d2             	movslq %edx,%rdx
  1014ef:	48 c1 e2 04          	shl    $0x4,%rdx
  1014f3:	48 01 d0             	add    %rdx,%rax
  1014f6:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  1014fa:	48 c1 ea 10          	shr    $0x10,%rdx
  1014fe:	66 89 50 06          	mov    %dx,0x6(%rax)
  idt[index].offset_h = (offset >> 32) & 0xFFFFFFFF;
  101502:	48 8b 05 c7 2b 00 00 	mov    0x2bc7(%rip),%rax        # 1040d0 <idt>
  101509:	8b 55 fc             	mov    -0x4(%rbp),%edx
  10150c:	48 63 d2             	movslq %edx,%rdx
  10150f:	48 c1 e2 04          	shl    $0x4,%rdx
  101513:	48 01 d0             	add    %rdx,%rax
  101516:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  10151a:	48 c1 ea 20          	shr    $0x20,%rdx
  10151e:	89 50 08             	mov    %edx,0x8(%rax)
  idt[index].access = ACS_INT;
  101521:	48 8b 05 a8 2b 00 00 	mov    0x2ba8(%rip),%rax        # 1040d0 <idt>
  101528:	8b 55 fc             	mov    -0x4(%rbp),%edx
  10152b:	48 63 d2             	movslq %edx,%rdx
  10152e:	48 c1 e2 04          	shl    $0x4,%rdx
  101532:	48 01 d0             	add    %rdx,%rax
  101535:	c6 40 05 8e          	movb   $0x8e,0x5(%rax)
  idt[index].cero = 0;
  101539:	48 8b 05 90 2b 00 00 	mov    0x2b90(%rip),%rax        # 1040d0 <idt>
  101540:	8b 55 fc             	mov    -0x4(%rbp),%edx
  101543:	48 63 d2             	movslq %edx,%rdx
  101546:	48 c1 e2 04          	shl    $0x4,%rdx
  10154a:	48 01 d0             	add    %rdx,%rax
  10154d:	c6 40 04 00          	movb   $0x0,0x4(%rax)
  idt[index].other_cero = (uint64_t) 0;
  101551:	48 8b 05 78 2b 00 00 	mov    0x2b78(%rip),%rax        # 1040d0 <idt>
  101558:	8b 55 fc             	mov    -0x4(%rbp),%edx
  10155b:	48 63 d2             	movslq %edx,%rdx
  10155e:	48 c1 e2 04          	shl    $0x4,%rdx
  101562:	48 01 d0             	add    %rdx,%rax
  101565:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%rax)
}
  10156c:	c9                   	leaveq 
  10156d:	c3                   	retq   

000000000010156e <getAscii>:
static int MAYUS = 0;
static int * target = 0;
//static int PRESSED = 0;


int getAscii(int val) {
  10156e:	55                   	push   %rbp
  10156f:	48 89 e5             	mov    %rsp,%rbp
  101572:	48 83 ec 18          	sub    $0x18,%rsp
  101576:	89 7d ec             	mov    %edi,-0x14(%rbp)
     MAYUS += (val == CAPS_LOCK) ? ( MAYUS ? -1 : 1) : 0;
  101579:	83 7d ec 3a          	cmpl   $0x3a,-0x14(%rbp)
  10157d:	75 18                	jne    101597 <getAscii+0x29>
  10157f:	8b 05 53 2b 00 00    	mov    0x2b53(%rip),%eax        # 1040d8 <MAYUS>
  101585:	85 c0                	test   %eax,%eax
  101587:	74 07                	je     101590 <getAscii+0x22>
  101589:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  10158e:	eb 0c                	jmp    10159c <getAscii+0x2e>
  101590:	b8 01 00 00 00       	mov    $0x1,%eax
  101595:	eb 05                	jmp    10159c <getAscii+0x2e>
  101597:	b8 00 00 00 00       	mov    $0x0,%eax
  10159c:	8b 15 36 2b 00 00    	mov    0x2b36(%rip),%edx        # 1040d8 <MAYUS>
  1015a2:	01 d0                	add    %edx,%eax
  1015a4:	89 05 2e 2b 00 00    	mov    %eax,0x2b2e(%rip)        # 1040d8 <MAYUS>

	int ascii = scancodeToAscii[val];
  1015aa:	8b 45 ec             	mov    -0x14(%rbp),%eax
  1015ad:	48 98                	cltq   
  1015af:	8b 04 85 c0 38 10 00 	mov    0x1038c0(,%rax,4),%eax
  1015b6:	89 45 fc             	mov    %eax,-0x4(%rbp)

	return ascii == 0 ? '?' : ( IS_ALPHA(ascii) ? ascii - MAYUS_DIFF*MAYUS : ascii);
  1015b9:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  1015bd:	74 36                	je     1015f5 <getAscii+0x87>
  1015bf:	83 7d fc 60          	cmpl   $0x60,-0x4(%rbp)
  1015c3:	7e 06                	jle    1015cb <getAscii+0x5d>
  1015c5:	83 7d fc 7a          	cmpl   $0x7a,-0x4(%rbp)
  1015c9:	7e 0c                	jle    1015d7 <getAscii+0x69>
  1015cb:	83 7d fc 40          	cmpl   $0x40,-0x4(%rbp)
  1015cf:	7e 1f                	jle    1015f0 <getAscii+0x82>
  1015d1:	83 7d fc 5a          	cmpl   $0x5a,-0x4(%rbp)
  1015d5:	7f 19                	jg     1015f0 <getAscii+0x82>
  1015d7:	8b 15 fb 2a 00 00    	mov    0x2afb(%rip),%edx        # 1040d8 <MAYUS>
  1015dd:	b8 00 00 00 00       	mov    $0x0,%eax
  1015e2:	29 d0                	sub    %edx,%eax
  1015e4:	c1 e0 05             	shl    $0x5,%eax
  1015e7:	89 c2                	mov    %eax,%edx
  1015e9:	8b 45 fc             	mov    -0x4(%rbp),%eax
  1015ec:	01 d0                	add    %edx,%eax
  1015ee:	eb 0a                	jmp    1015fa <getAscii+0x8c>
  1015f0:	8b 45 fc             	mov    -0x4(%rbp),%eax
  1015f3:	eb 05                	jmp    1015fa <getAscii+0x8c>
  1015f5:	b8 3f 00 00 00       	mov    $0x3f,%eax
}
  1015fa:	c9                   	leaveq 
  1015fb:	c3                   	retq   

00000000001015fc <kb_read>:


int kb_read() {
  1015fc:	55                   	push   %rbp
  1015fd:	48 89 e5             	mov    %rsp,%rbp
  101600:	48 83 ec 10          	sub    $0x10,%rsp
	int sc;
	// do {
		sc = kbReadUntilCode();
  101604:	b8 00 00 00 00       	mov    $0x0,%eax
  101609:	e8 63 04 00 00       	callq  101a71 <kbReadUntilCode>
  10160e:	0f be c0             	movsbl %al,%eax
  101611:	89 45 fc             	mov    %eax,-0x4(%rbp)
	// } while (sc & 0x80); // sigo escaneando mientras el dato no haya sido transferido completamente

	return getAscii(sc);
  101614:	8b 45 fc             	mov    -0x4(%rbp),%eax
  101617:	89 c7                	mov    %eax,%edi
  101619:	e8 50 ff ff ff       	callq  10156e <getAscii>
}
  10161e:	c9                   	leaveq 
  10161f:	c3                   	retq   

0000000000101620 <keyboardDriver>:


void keyboardDriver() {
  101620:	55                   	push   %rbp
  101621:	48 89 e5             	mov    %rsp,%rbp
  101624:	53                   	push   %rbx
  101625:	48 83 ec 18          	sub    $0x18,%rsp
     //ncPrint("HOLA");
     int c;
     while(keyboardActivated()) {
  101629:	eb 0d                	jmp    101638 <keyboardDriver+0x18>
          c = getKbCode();
  10162b:	b8 00 00 00 00       	mov    $0x0,%eax
  101630:	e8 72 04 00 00       	callq  101aa7 <getKbCode>
  101635:	89 45 ec             	mov    %eax,-0x14(%rbp)
     while(keyboardActivated()) {
  101638:	b8 00 00 00 00       	mov    $0x0,%eax
  10163d:	e8 6d 04 00 00       	callq  101aaf <keyboardActivated>
  101642:	85 c0                	test   %eax,%eax
  101644:	75 e5                	jne    10162b <keyboardDriver+0xb>
     }
          if (target && !(c & 0x80))
  101646:	48 8b 05 93 2a 00 00 	mov    0x2a93(%rip),%rax        # 1040e0 <target>
  10164d:	48 85 c0             	test   %rax,%rax
  101650:	74 1f                	je     101671 <keyboardDriver+0x51>
  101652:	8b 45 ec             	mov    -0x14(%rbp),%eax
  101655:	25 80 00 00 00       	and    $0x80,%eax
  10165a:	85 c0                	test   %eax,%eax
  10165c:	75 13                	jne    101671 <keyboardDriver+0x51>
          *target = getAscii(c);
  10165e:	48 8b 1d 7b 2a 00 00 	mov    0x2a7b(%rip),%rbx        # 1040e0 <target>
  101665:	8b 45 ec             	mov    -0x14(%rbp),%eax
  101668:	89 c7                	mov    %eax,%edi
  10166a:	e8 ff fe ff ff       	callq  10156e <getAscii>
  10166f:	89 03                	mov    %eax,(%rbx)
}
  101671:	48 83 c4 18          	add    $0x18,%rsp
  101675:	5b                   	pop    %rbx
  101676:	5d                   	pop    %rbp
  101677:	c3                   	retq   

0000000000101678 <set_kb_target>:
      	

void set_kb_target(int * var) {
  101678:	55                   	push   %rbp
  101679:	48 89 e5             	mov    %rsp,%rbp
  10167c:	48 83 ec 08          	sub    $0x8,%rsp
  101680:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
     target = var;
  101684:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  101688:	48 89 05 51 2a 00 00 	mov    %rax,0x2a51(%rip)        # 1040e0 <target>
}
  10168f:	c9                   	leaveq 
  101690:	c3                   	retq   

0000000000101691 <readFromKeyboard>:

int readFromKeyboard(char * buf, uint64_t count, int ascii) {
  101691:	55                   	push   %rbp
  101692:	48 89 e5             	mov    %rsp,%rbp
  101695:	53                   	push   %rbx
  101696:	48 83 ec 38          	sub    $0x38,%rsp
  10169a:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  10169e:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  1016a2:	89 55 cc             	mov    %edx,-0x34(%rbp)
     //picMasterMask(0xFE);
     for(int i=0 ; i<count ; i++) {
  1016a5:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  1016ac:	eb 3c                	jmp    1016ea <readFromKeyboard+0x59>
          buf[i] = kb_read();
  1016ae:	8b 45 ec             	mov    -0x14(%rbp),%eax
  1016b1:	48 63 d0             	movslq %eax,%rdx
  1016b4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  1016b8:	48 8d 1c 02          	lea    (%rdx,%rax,1),%rbx
  1016bc:	b8 00 00 00 00       	mov    $0x0,%eax
  1016c1:	e8 36 ff ff ff       	callq  1015fc <kb_read>
  1016c6:	88 03                	mov    %al,(%rbx)
          if (ascii && !PRINTABLE(buf[i]))
  1016c8:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  1016cc:	74 18                	je     1016e6 <readFromKeyboard+0x55>
  1016ce:	8b 45 ec             	mov    -0x14(%rbp),%eax
  1016d1:	48 63 d0             	movslq %eax,%rdx
  1016d4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  1016d8:	48 01 d0             	add    %rdx,%rax
  1016db:	0f b6 00             	movzbl (%rax),%eax
  1016de:	3c 3a                	cmp    $0x3a,%al
  1016e0:	75 04                	jne    1016e6 <readFromKeyboard+0x55>
               i--;
  1016e2:	83 6d ec 01          	subl   $0x1,-0x14(%rbp)
     for(int i=0 ; i<count ; i++) {
  1016e6:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  1016ea:	8b 45 ec             	mov    -0x14(%rbp),%eax
  1016ed:	48 98                	cltq   
  1016ef:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  1016f3:	72 b9                	jb     1016ae <readFromKeyboard+0x1d>
     }
     //picMasterMask(0xFC);
     return count;
  1016f5:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  1016f9:	48 83 c4 38          	add    $0x38,%rsp
  1016fd:	5b                   	pop    %rbx
  1016fe:	5d                   	pop    %rbp
  1016ff:	c3                   	retq   

0000000000101700 <clearBSS>:
typedef int (*EntryPoint)();



void clearBSS(void * bssAddress, uint64_t bssSize)
{
  101700:	55                   	push   %rbp
  101701:	48 89 e5             	mov    %rsp,%rbp
  101704:	48 83 ec 10          	sub    $0x10,%rsp
  101708:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  10170c:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	memset(bssAddress, 0, bssSize);
  101710:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  101714:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  101718:	be 00 00 00 00       	mov    $0x0,%esi
  10171d:	48 89 c7             	mov    %rax,%rdi
  101720:	e8 ec e8 ff ff       	callq  100011 <memset>
}
  101725:	c9                   	leaveq 
  101726:	c3                   	retq   

0000000000101727 <getStackBase>:

void * getStackBase()
{
  101727:	55                   	push   %rbp
  101728:	48 89 e5             	mov    %rsp,%rbp
	return (void*)(
		(uint64_t)&endOfKernel
		+ PageSize * 8				//The size of the stack itself, 32KiB
  10172b:	b8 00 10 00 00       	mov    $0x1000,%eax
  101730:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  101737:	00 
		(uint64_t)&endOfKernel
  101738:	b8 00 50 10 00       	mov    $0x105000,%eax
		- sizeof(uint64_t)			//Begin at the top of the stack
  10173d:	48 83 e8 08          	sub    $0x8,%rax
  101741:	48 01 d0             	add    %rdx,%rax
	);
}
  101744:	5d                   	pop    %rbp
  101745:	c3                   	retq   

0000000000101746 <initializeKernelBinary>:

void * initializeKernelBinary()
{
  101746:	55                   	push   %rbp
  101747:	48 89 e5             	mov    %rsp,%rbp
  10174a:	48 83 ec 10          	sub    $0x10,%rsp
	ncInitVideoConsole();
  10174e:	b8 00 00 00 00       	mov    $0x0,%eax
  101753:	e8 ab f1 ff ff       	callq  100903 <ncInitVideoConsole>

	ncPrint("[Loading modules]");
  101758:	bf 50 20 10 00       	mov    $0x102050,%edi
  10175d:	e8 7a f8 ff ff       	callq  100fdc <ncPrint>
	ncNewline();
  101762:	b8 00 00 00 00       	mov    $0x0,%eax
  101767:	e8 00 f9 ff ff       	callq  10106c <ncNewline>
	void * moduleAddresses[] = {
  10176c:	b8 00 00 40 00       	mov    $0x400000,%eax
  101771:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  101775:	b8 00 00 50 00       	mov    $0x500000,%eax
  10177a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		sampleCodeModuleAddress,
		sampleDataModuleAddress
	};

	loadModules(&endOfKernelBinary, moduleAddresses);
  10177e:	48 8d 45 f0          	lea    -0x10(%rbp),%rax
  101782:	48 89 c6             	mov    %rax,%rsi
  101785:	bf bc 3c 10 00       	mov    $0x103cbc,%edi
  10178a:	e8 72 fb ff ff       	callq  101301 <loadModules>
	ncPrint("[Done]");
  10178f:	bf 62 20 10 00       	mov    $0x102062,%edi
  101794:	e8 43 f8 ff ff       	callq  100fdc <ncPrint>
	ncNewline();
  101799:	b8 00 00 00 00       	mov    $0x0,%eax
  10179e:	e8 c9 f8 ff ff       	callq  10106c <ncNewline>
	ncNewline();
  1017a3:	b8 00 00 00 00       	mov    $0x0,%eax
  1017a8:	e8 bf f8 ff ff       	callq  10106c <ncNewline>

	ncPrint("[Initializing kernel's binary]");
  1017ad:	bf 70 20 10 00       	mov    $0x102070,%edi
  1017b2:	e8 25 f8 ff ff       	callq  100fdc <ncPrint>
	ncNewline();
  1017b7:	b8 00 00 00 00       	mov    $0x0,%eax
  1017bc:	e8 ab f8 ff ff       	callq  10106c <ncNewline>

	clearBSS(&bss, &endOfKernel - &bss);
  1017c1:	ba 00 50 10 00       	mov    $0x105000,%edx
  1017c6:	b8 00 40 10 00       	mov    $0x104000,%eax
  1017cb:	48 29 c2             	sub    %rax,%rdx
  1017ce:	48 89 d0             	mov    %rdx,%rax
  1017d1:	48 89 c6             	mov    %rax,%rsi
  1017d4:	bf 00 40 10 00       	mov    $0x104000,%edi
  1017d9:	e8 22 ff ff ff       	callq  101700 <clearBSS>

	ncPrint("  text: 0x");
  1017de:	bf 8f 20 10 00       	mov    $0x10208f,%edi
  1017e3:	e8 f4 f7 ff ff       	callq  100fdc <ncPrint>
	ncPrintHex((uint64_t)&text);
  1017e8:	b8 00 00 10 00       	mov    $0x100000,%eax
  1017ed:	48 89 c7             	mov    %rax,%rdi
  1017f0:	e8 3e f9 ff ff       	callq  101133 <ncPrintHex>
	ncNewline();
  1017f5:	b8 00 00 00 00       	mov    $0x0,%eax
  1017fa:	e8 6d f8 ff ff       	callq  10106c <ncNewline>
	ncPrint("  rodata: 0x");
  1017ff:	bf 9a 20 10 00       	mov    $0x10209a,%edi
  101804:	e8 d3 f7 ff ff       	callq  100fdc <ncPrint>
	ncPrintHex((uint64_t)&rodata);
  101809:	b8 00 20 10 00       	mov    $0x102000,%eax
  10180e:	48 89 c7             	mov    %rax,%rdi
  101811:	e8 1d f9 ff ff       	callq  101133 <ncPrintHex>
	ncNewline();
  101816:	b8 00 00 00 00       	mov    $0x0,%eax
  10181b:	e8 4c f8 ff ff       	callq  10106c <ncNewline>
	ncPrint("  data: 0x");
  101820:	bf a7 20 10 00       	mov    $0x1020a7,%edi
  101825:	e8 b2 f7 ff ff       	callq  100fdc <ncPrint>
	ncPrintHex((uint64_t)&data);
  10182a:	b8 00 30 10 00       	mov    $0x103000,%eax
  10182f:	48 89 c7             	mov    %rax,%rdi
  101832:	e8 fc f8 ff ff       	callq  101133 <ncPrintHex>
	ncNewline();
  101837:	b8 00 00 00 00       	mov    $0x0,%eax
  10183c:	e8 2b f8 ff ff       	callq  10106c <ncNewline>
	ncPrint("  bss: 0x");
  101841:	bf b2 20 10 00       	mov    $0x1020b2,%edi
  101846:	e8 91 f7 ff ff       	callq  100fdc <ncPrint>
	ncPrintHex((uint64_t)&bss);
  10184b:	b8 00 40 10 00       	mov    $0x104000,%eax
  101850:	48 89 c7             	mov    %rax,%rdi
  101853:	e8 db f8 ff ff       	callq  101133 <ncPrintHex>
	ncNewline();
  101858:	b8 00 00 00 00       	mov    $0x0,%eax
  10185d:	e8 0a f8 ff ff       	callq  10106c <ncNewline>
	
	ncNewline();
  101862:	b8 00 00 00 00       	mov    $0x0,%eax
  101867:	e8 00 f8 ff ff       	callq  10106c <ncNewline>
	ncNewline();
  10186c:	b8 00 00 00 00       	mov    $0x0,%eax
  101871:	e8 f6 f7 ff ff       	callq  10106c <ncNewline>
	return getStackBase();
  101876:	b8 00 00 00 00       	mov    $0x0,%eax
  10187b:	e8 a7 fe ff ff       	callq  101727 <getStackBase>
}
  101880:	c9                   	leaveq 
  101881:	c3                   	retq   

0000000000101882 <main>:




int main()
{		
  101882:	55                   	push   %rbp
  101883:	48 89 e5             	mov    %rsp,%rbp
	load_idt();
  101886:	b8 00 00 00 00       	mov    $0x0,%eax
  10188b:	e8 b4 fb ff ff       	callq  101444 <load_idt>
	//while (1);
	ncInitVideoConsole();
  101890:	b8 00 00 00 00       	mov    $0x0,%eax
  101895:	e8 69 f0 ff ff       	callq  100903 <ncInitVideoConsole>
	ncNewline();
  10189a:	b8 00 00 00 00       	mov    $0x0,%eax
  10189f:	e8 c8 f7 ff ff       	callq  10106c <ncNewline>

	ncPrint("  Calling the sample code module returned: ");
  1018a4:	bf c0 20 10 00       	mov    $0x1020c0,%edi
  1018a9:	e8 2e f7 ff ff       	callq  100fdc <ncPrint>
	ncClear();
  1018ae:	b8 00 00 00 00       	mov    $0x0,%eax
  1018b3:	e8 e8 f8 ff ff       	callq  1011a0 <ncClear>
	ncPrintHex(((EntryPoint)sampleCodeModuleAddress)());
  1018b8:	b8 00 00 40 00       	mov    $0x400000,%eax
  1018bd:	48 89 c2             	mov    %rax,%rdx
  1018c0:	b8 00 00 00 00       	mov    $0x0,%eax
  1018c5:	ff d2                	callq  *%rdx
  1018c7:	48 98                	cltq   
  1018c9:	48 89 c7             	mov    %rax,%rdi
  1018cc:	e8 62 f8 ff ff       	callq  101133 <ncPrintHex>
	// ncNewline();
	// ncPrint("  Sample data module contents: ");
	// ncPrint((char*)sampleDataModuleAddress);
	// ncNewline();

	ncPrint("[Finished]");
  1018d1:	bf ec 20 10 00       	mov    $0x1020ec,%edi
  1018d6:	e8 01 f7 ff ff       	callq  100fdc <ncPrint>
	return 0;
  1018db:	b8 00 00 00 00       	mov    $0x0,%eax
}
  1018e0:	5d                   	pop    %rbp
  1018e1:	c3                   	retq   
  1018e2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1018e9:	00 00 00 
  1018ec:	0f 1f 40 00          	nopl   0x0(%rax)

00000000001018f0 <_sysCallHandlerMaster>:
  1018f0:	fa                   	cli    
  1018f1:	53                   	push   %rbx
  1018f2:	51                   	push   %rcx
  1018f3:	52                   	push   %rdx
  1018f4:	55                   	push   %rbp
  1018f5:	57                   	push   %rdi
  1018f6:	56                   	push   %rsi
  1018f7:	41 50                	push   %r8
  1018f9:	41 51                	push   %r9
  1018fb:	41 52                	push   %r10
  1018fd:	41 53                	push   %r11
  1018ff:	41 54                	push   %r12
  101901:	41 55                	push   %r13
  101903:	41 56                	push   %r14
  101905:	41 57                	push   %r15
  101907:	49 89 c0             	mov    %rax,%r8
  10190a:	e8 6b e9 ff ff       	callq  10027a <sysCallDispatcher>
  10190f:	41 5f                	pop    %r15
  101911:	41 5e                	pop    %r14
  101913:	41 5d                	pop    %r13
  101915:	41 5c                	pop    %r12
  101917:	41 5b                	pop    %r11
  101919:	41 5a                	pop    %r10
  10191b:	41 59                	pop    %r9
  10191d:	41 58                	pop    %r8
  10191f:	5e                   	pop    %rsi
  101920:	5f                   	pop    %rdi
  101921:	5d                   	pop    %rbp
  101922:	5a                   	pop    %rdx
  101923:	59                   	pop    %rcx
  101924:	5b                   	pop    %rbx
  101925:	fb                   	sti    
  101926:	48 cf                	iretq  

0000000000101928 <_hlt>:
  101928:	fb                   	sti    
  101929:	f4                   	hlt    
  10192a:	c3                   	retq   

000000000010192b <_cli>:
  10192b:	fa                   	cli    
  10192c:	c3                   	retq   

000000000010192d <_sti>:
  10192d:	fb                   	sti    
  10192e:	c3                   	retq   

000000000010192f <picMasterMask>:
  10192f:	55                   	push   %rbp
  101930:	48 89 e5             	mov    %rsp,%rbp
  101933:	66 89 f8             	mov    %di,%ax
  101936:	e6 21                	out    %al,$0x21
  101938:	5d                   	pop    %rbp
  101939:	c3                   	retq   

000000000010193a <picSlaveMask>:
  10193a:	55                   	push   %rbp
  10193b:	48 89 e5             	mov    %rsp,%rbp
  10193e:	66 89 f8             	mov    %di,%ax
  101941:	e6 a1                	out    %al,$0xa1
  101943:	5d                   	pop    %rbp
  101944:	c3                   	retq   

0000000000101945 <_irq00Handler>:
  101945:	50                   	push   %rax
  101946:	53                   	push   %rbx
  101947:	51                   	push   %rcx
  101948:	52                   	push   %rdx
  101949:	55                   	push   %rbp
  10194a:	57                   	push   %rdi
  10194b:	56                   	push   %rsi
  10194c:	41 50                	push   %r8
  10194e:	41 51                	push   %r9
  101950:	41 52                	push   %r10
  101952:	41 53                	push   %r11
  101954:	41 54                	push   %r12
  101956:	41 55                	push   %r13
  101958:	41 56                	push   %r14
  10195a:	41 57                	push   %r15
  10195c:	bf 00 00 00 00       	mov    $0x0,%edi
  101961:	e8 0b ef ff ff       	callq  100871 <irqDispatcher>
  101966:	b0 20                	mov    $0x20,%al
  101968:	e6 20                	out    %al,$0x20
  10196a:	41 5f                	pop    %r15
  10196c:	41 5e                	pop    %r14
  10196e:	41 5d                	pop    %r13
  101970:	41 5c                	pop    %r12
  101972:	41 5b                	pop    %r11
  101974:	41 5a                	pop    %r10
  101976:	41 59                	pop    %r9
  101978:	41 58                	pop    %r8
  10197a:	5e                   	pop    %rsi
  10197b:	5f                   	pop    %rdi
  10197c:	5d                   	pop    %rbp
  10197d:	5a                   	pop    %rdx
  10197e:	59                   	pop    %rcx
  10197f:	5b                   	pop    %rbx
  101980:	58                   	pop    %rax
  101981:	48 cf                	iretq  

0000000000101983 <_irq01Handler>:
  101983:	50                   	push   %rax
  101984:	53                   	push   %rbx
  101985:	51                   	push   %rcx
  101986:	52                   	push   %rdx
  101987:	55                   	push   %rbp
  101988:	57                   	push   %rdi
  101989:	56                   	push   %rsi
  10198a:	41 50                	push   %r8
  10198c:	41 51                	push   %r9
  10198e:	41 52                	push   %r10
  101990:	41 53                	push   %r11
  101992:	41 54                	push   %r12
  101994:	41 55                	push   %r13
  101996:	41 56                	push   %r14
  101998:	41 57                	push   %r15
  10199a:	bf 01 00 00 00       	mov    $0x1,%edi
  10199f:	e8 cd ee ff ff       	callq  100871 <irqDispatcher>
  1019a4:	b0 20                	mov    $0x20,%al
  1019a6:	e6 20                	out    %al,$0x20
  1019a8:	41 5f                	pop    %r15
  1019aa:	41 5e                	pop    %r14
  1019ac:	41 5d                	pop    %r13
  1019ae:	41 5c                	pop    %r12
  1019b0:	41 5b                	pop    %r11
  1019b2:	41 5a                	pop    %r10
  1019b4:	41 59                	pop    %r9
  1019b6:	41 58                	pop    %r8
  1019b8:	5e                   	pop    %rsi
  1019b9:	5f                   	pop    %rdi
  1019ba:	5d                   	pop    %rbp
  1019bb:	5a                   	pop    %rdx
  1019bc:	59                   	pop    %rcx
  1019bd:	5b                   	pop    %rbx
  1019be:	58                   	pop    %rax
  1019bf:	48 cf                	iretq  

00000000001019c1 <_exception00Handler>:
  1019c1:	50                   	push   %rax
  1019c2:	53                   	push   %rbx
  1019c3:	51                   	push   %rcx
  1019c4:	52                   	push   %rdx
  1019c5:	55                   	push   %rbp
  1019c6:	57                   	push   %rdi
  1019c7:	56                   	push   %rsi
  1019c8:	41 50                	push   %r8
  1019ca:	41 51                	push   %r9
  1019cc:	41 52                	push   %r10
  1019ce:	41 53                	push   %r11
  1019d0:	41 54                	push   %r12
  1019d2:	41 55                	push   %r13
  1019d4:	41 56                	push   %r14
  1019d6:	41 57                	push   %r15
  1019d8:	bf 00 00 00 00       	mov    $0x0,%edi
  1019dd:	48 89 e6             	mov    %rsp,%rsi
  1019e0:	e8 dc ee ff ff       	callq  1008c1 <exceptionDispatcher>
  1019e5:	41 5f                	pop    %r15
  1019e7:	41 5e                	pop    %r14
  1019e9:	41 5d                	pop    %r13
  1019eb:	41 5c                	pop    %r12
  1019ed:	41 5b                	pop    %r11
  1019ef:	41 5a                	pop    %r10
  1019f1:	41 59                	pop    %r9
  1019f3:	41 58                	pop    %r8
  1019f5:	5e                   	pop    %rsi
  1019f6:	5f                   	pop    %rdi
  1019f7:	5d                   	pop    %rbp
  1019f8:	5a                   	pop    %rdx
  1019f9:	59                   	pop    %rcx
  1019fa:	5b                   	pop    %rbx
  1019fb:	58                   	pop    %rax
  1019fc:	48 cf                	iretq  

00000000001019fe <_exception06Handler>:
  1019fe:	50                   	push   %rax
  1019ff:	53                   	push   %rbx
  101a00:	51                   	push   %rcx
  101a01:	52                   	push   %rdx
  101a02:	55                   	push   %rbp
  101a03:	57                   	push   %rdi
  101a04:	56                   	push   %rsi
  101a05:	41 50                	push   %r8
  101a07:	41 51                	push   %r9
  101a09:	41 52                	push   %r10
  101a0b:	41 53                	push   %r11
  101a0d:	41 54                	push   %r12
  101a0f:	41 55                	push   %r13
  101a11:	41 56                	push   %r14
  101a13:	41 57                	push   %r15
  101a15:	bf 06 00 00 00       	mov    $0x6,%edi
  101a1a:	48 89 e6             	mov    %rsp,%rsi
  101a1d:	e8 9f ee ff ff       	callq  1008c1 <exceptionDispatcher>
  101a22:	41 5f                	pop    %r15
  101a24:	41 5e                	pop    %r14
  101a26:	41 5d                	pop    %r13
  101a28:	41 5c                	pop    %r12
  101a2a:	41 5b                	pop    %r11
  101a2c:	41 5a                	pop    %r10
  101a2e:	41 59                	pop    %r9
  101a30:	41 58                	pop    %r8
  101a32:	5e                   	pop    %rsi
  101a33:	5f                   	pop    %rdi
  101a34:	5d                   	pop    %rbp
  101a35:	5a                   	pop    %rdx
  101a36:	59                   	pop    %rcx
  101a37:	5b                   	pop    %rbx
  101a38:	58                   	pop    %rax
  101a39:	48 cf                	iretq  

0000000000101a3b <haltcpu>:
  101a3b:	fa                   	cli    
  101a3c:	f4                   	hlt    
  101a3d:	c3                   	retq   
  101a3e:	66 90                	xchg   %ax,%ax

0000000000101a40 <cpuVendor>:
  101a40:	55                   	push   %rbp
  101a41:	48 89 e5             	mov    %rsp,%rbp
  101a44:	53                   	push   %rbx
  101a45:	b8 00 00 00 00       	mov    $0x0,%eax
  101a4a:	0f a2                	cpuid  
  101a4c:	89 1f                	mov    %ebx,(%rdi)
  101a4e:	89 57 04             	mov    %edx,0x4(%rdi)
  101a51:	89 4f 08             	mov    %ecx,0x8(%rdi)
  101a54:	c6 47 0d 00          	movb   $0x0,0xd(%rdi)
  101a58:	48 89 f8             	mov    %rdi,%rax
  101a5b:	5b                   	pop    %rbx
  101a5c:	48 89 ec             	mov    %rbp,%rsp
  101a5f:	5d                   	pop    %rbp
  101a60:	c3                   	retq   

0000000000101a61 <kbd_wait_till_data>:
  101a61:	e4 64                	in     $0x64,%al
  101a63:	24 01                	and    $0x1,%al
  101a65:	74 fa                	je     101a61 <kbd_wait_till_data>

0000000000101a67 <kbd_wait_till_data.iscomplete>:
  101a67:	48 31 c0             	xor    %rax,%rax
  101a6a:	e4 60                	in     $0x60,%al
  101a6c:	a8 80                	test   $0x80,%al
  101a6e:	75 f7                	jne    101a67 <kbd_wait_till_data.iscomplete>
  101a70:	c3                   	retq   

0000000000101a71 <kbReadUntilCode>:
  101a71:	53                   	push   %rbx
  101a72:	51                   	push   %rcx
  101a73:	52                   	push   %rdx
  101a74:	55                   	push   %rbp
  101a75:	57                   	push   %rdi
  101a76:	56                   	push   %rsi
  101a77:	41 50                	push   %r8
  101a79:	41 51                	push   %r9
  101a7b:	41 52                	push   %r10
  101a7d:	41 53                	push   %r11
  101a7f:	41 54                	push   %r12
  101a81:	41 55                	push   %r13
  101a83:	41 56                	push   %r14
  101a85:	41 57                	push   %r15
  101a87:	b0 d0                	mov    $0xd0,%al
  101a89:	e6 64                	out    %al,$0x64
  101a8b:	e8 d1 ff ff ff       	callq  101a61 <kbd_wait_till_data>
  101a90:	41 5f                	pop    %r15
  101a92:	41 5e                	pop    %r14
  101a94:	41 5d                	pop    %r13
  101a96:	41 5c                	pop    %r12
  101a98:	41 5b                	pop    %r11
  101a9a:	41 5a                	pop    %r10
  101a9c:	41 59                	pop    %r9
  101a9e:	41 58                	pop    %r8
  101aa0:	5e                   	pop    %rsi
  101aa1:	5f                   	pop    %rdi
  101aa2:	5d                   	pop    %rbp
  101aa3:	5a                   	pop    %rdx
  101aa4:	59                   	pop    %rcx
  101aa5:	5b                   	pop    %rbx
  101aa6:	c3                   	retq   

0000000000101aa7 <getKbCode>:
  101aa7:	b8 00 00 00 00       	mov    $0x0,%eax
  101aac:	e4 60                	in     $0x60,%al
  101aae:	c3                   	retq   

0000000000101aaf <keyboardActivated>:
  101aaf:	b8 00 00 00 00       	mov    $0x0,%eax
  101ab4:	e4 64                	in     $0x64,%al
  101ab6:	24 01                	and    $0x1,%al
  101ab8:	c3                   	retq   

0000000000101ab9 <getRTC>:
  101ab9:	55                   	push   %rbp
  101aba:	48 89 e5             	mov    %rsp,%rbp
  101abd:	48 89 f8             	mov    %rdi,%rax
  101ac0:	e6 70                	out    %al,$0x70
  101ac2:	e4 71                	in     $0x71,%al
  101ac4:	48 89 ec             	mov    %rbp,%rsp
  101ac7:	5d                   	pop    %rbp
  101ac8:	c3                   	retq   
  101ac9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101ad0:	00 00 00 
  101ad3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101ada:	00 00 00 
  101add:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101ae4:	00 00 00 
  101ae7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101aee:	00 00 00 
  101af1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101af8:	00 00 00 
  101afb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101b02:	00 00 00 
  101b05:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101b0c:	00 00 00 
  101b0f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101b16:	00 00 00 
  101b19:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101b20:	00 00 00 
  101b23:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101b2a:	00 00 00 
  101b2d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101b34:	00 00 00 
  101b37:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101b3e:	00 00 00 
  101b41:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101b48:	00 00 00 
  101b4b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101b52:	00 00 00 
  101b55:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101b5c:	00 00 00 
  101b5f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101b66:	00 00 00 
  101b69:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101b70:	00 00 00 
  101b73:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101b7a:	00 00 00 
  101b7d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101b84:	00 00 00 
  101b87:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101b8e:	00 00 00 
  101b91:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101b98:	00 00 00 
  101b9b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101ba2:	00 00 00 
  101ba5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101bac:	00 00 00 
  101baf:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101bb6:	00 00 00 
  101bb9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101bc0:	00 00 00 
  101bc3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101bca:	00 00 00 
  101bcd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101bd4:	00 00 00 
  101bd7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101bde:	00 00 00 
  101be1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101be8:	00 00 00 
  101beb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101bf2:	00 00 00 
  101bf5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101bfc:	00 00 00 
  101bff:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101c06:	00 00 00 
  101c09:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101c10:	00 00 00 
  101c13:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101c1a:	00 00 00 
  101c1d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101c24:	00 00 00 
  101c27:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101c2e:	00 00 00 
  101c31:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101c38:	00 00 00 
  101c3b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101c42:	00 00 00 
  101c45:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101c4c:	00 00 00 
  101c4f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101c56:	00 00 00 
  101c59:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101c60:	00 00 00 
  101c63:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101c6a:	00 00 00 
  101c6d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101c74:	00 00 00 
  101c77:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101c7e:	00 00 00 
  101c81:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101c88:	00 00 00 
  101c8b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101c92:	00 00 00 
  101c95:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101c9c:	00 00 00 
  101c9f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101ca6:	00 00 00 
  101ca9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101cb0:	00 00 00 
  101cb3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101cba:	00 00 00 
  101cbd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101cc4:	00 00 00 
  101cc7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101cce:	00 00 00 
  101cd1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101cd8:	00 00 00 
  101cdb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101ce2:	00 00 00 
  101ce5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101cec:	00 00 00 
  101cef:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101cf6:	00 00 00 
  101cf9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101d00:	00 00 00 
  101d03:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101d0a:	00 00 00 
  101d0d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101d14:	00 00 00 
  101d17:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101d1e:	00 00 00 
  101d21:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101d28:	00 00 00 
  101d2b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101d32:	00 00 00 
  101d35:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101d3c:	00 00 00 
  101d3f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101d46:	00 00 00 
  101d49:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101d50:	00 00 00 
  101d53:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101d5a:	00 00 00 
  101d5d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101d64:	00 00 00 
  101d67:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101d6e:	00 00 00 
  101d71:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101d78:	00 00 00 
  101d7b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101d82:	00 00 00 
  101d85:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101d8c:	00 00 00 
  101d8f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101d96:	00 00 00 
  101d99:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101da0:	00 00 00 
  101da3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101daa:	00 00 00 
  101dad:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101db4:	00 00 00 
  101db7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101dbe:	00 00 00 
  101dc1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101dc8:	00 00 00 
  101dcb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101dd2:	00 00 00 
  101dd5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101ddc:	00 00 00 
  101ddf:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101de6:	00 00 00 
  101de9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101df0:	00 00 00 
  101df3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101dfa:	00 00 00 
  101dfd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101e04:	00 00 00 
  101e07:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101e0e:	00 00 00 
  101e11:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101e18:	00 00 00 
  101e1b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101e22:	00 00 00 
  101e25:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101e2c:	00 00 00 
  101e2f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101e36:	00 00 00 
  101e39:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101e40:	00 00 00 
  101e43:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101e4a:	00 00 00 
  101e4d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101e54:	00 00 00 
  101e57:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101e5e:	00 00 00 
  101e61:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101e68:	00 00 00 
  101e6b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101e72:	00 00 00 
  101e75:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101e7c:	00 00 00 
  101e7f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101e86:	00 00 00 
  101e89:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101e90:	00 00 00 
  101e93:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101e9a:	00 00 00 
  101e9d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101ea4:	00 00 00 
  101ea7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101eae:	00 00 00 
  101eb1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101eb8:	00 00 00 
  101ebb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101ec2:	00 00 00 
  101ec5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101ecc:	00 00 00 
  101ecf:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101ed6:	00 00 00 
  101ed9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101ee0:	00 00 00 
  101ee3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101eea:	00 00 00 
  101eed:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101ef4:	00 00 00 
  101ef7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101efe:	00 00 00 
  101f01:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101f08:	00 00 00 
  101f0b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101f12:	00 00 00 
  101f15:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101f1c:	00 00 00 
  101f1f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101f26:	00 00 00 
  101f29:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101f30:	00 00 00 
  101f33:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101f3a:	00 00 00 
  101f3d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101f44:	00 00 00 
  101f47:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101f4e:	00 00 00 
  101f51:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101f58:	00 00 00 
  101f5b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101f62:	00 00 00 
  101f65:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101f6c:	00 00 00 
  101f6f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101f76:	00 00 00 
  101f79:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101f80:	00 00 00 
  101f83:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101f8a:	00 00 00 
  101f8d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101f94:	00 00 00 
  101f97:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101f9e:	00 00 00 
  101fa1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101fa8:	00 00 00 
  101fab:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101fb2:	00 00 00 
  101fb5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101fbc:	00 00 00 
  101fbf:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101fc6:	00 00 00 
  101fc9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101fd0:	00 00 00 
  101fd3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101fda:	00 00 00 
  101fdd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101fe4:	00 00 00 
  101fe7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101fee:	00 00 00 
  101ff1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  101ff8:	00 00 00 
  101ffb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000102000 <rodata>:
  102000:	20 20                	and    %ah,(%rax)
  102002:	57                   	push   %rdi
  102003:	69 6c 6c 20 63 6f 70 	imul   $0x79706f63,0x20(%rsp,%rbp,2),%ebp
  10200a:	79 
  10200b:	20 6d 6f             	and    %ch,0x6f(%rbp)
  10200e:	64 75 6c             	fs jne 10207d <sampleDataModuleAddress+0x35>
  102011:	65 20 61 74          	and    %ah,%gs:0x74(%rcx)
  102015:	20 30                	and    %dh,(%rax)
  102017:	78 00                	js     102019 <rodata+0x19>
  102019:	20 74 6f 20          	and    %dh,0x20(%rdi,%rbp,2)
  10201d:	30 78 00             	xor    %bh,0x0(%rax)
  102020:	20 28                	and    %ch,(%rax)
  102022:	00 20                	add    %ah,(%rax)
  102024:	62                   	(bad)  
  102025:	79 74                	jns    10209b <sampleDataModuleAddress+0x53>
  102027:	65 73 29             	gs jae 102053 <sampleDataModuleAddress+0xb>
  10202a:	00 20                	add    %ah,(%rax)
  10202c:	5b                   	pop    %rbx
  10202d:	44 6f                	rex.R outsl %ds:(%rsi),(%dx)
  10202f:	6e                   	outsb  %ds:(%rsi),(%dx)
  102030:	65 5d                	gs pop %rbp
  102032:	00 0f                	add    %cl,(%rdi)
  102034:	1f                   	(bad)  
  102035:	44 00 00             	add    %r8b,(%rax)

0000000000102038 <PageSize>:
  102038:	00 10 00 00 00 00 00 00                             ........

0000000000102040 <sampleCodeModuleAddress>:
  102040:	00 00 40 00 00 00 00 00                             ..@.....

0000000000102048 <sampleDataModuleAddress>:
  102048:	00 00 50 00 00 00 00 00 5b 4c 6f 61 64 69 6e 67     ..P.....[Loading
  102058:	20 6d 6f 64 75 6c 65 73 5d 00 5b 44 6f 6e 65 5d      modules].[Done]
	...
  102070:	5b 49 6e 69 74 69 61 6c 69 7a 69 6e 67 20 6b 65     [Initializing ke
  102080:	72 6e 65 6c 27 73 20 62 69 6e 61 72 79 5d 00 20     rnel's binary]. 
  102090:	20 74 65 78 74 3a 20 30 78 00 20 20 72 6f 64 61      text: 0x.  roda
  1020a0:	74 61 3a 20 30 78 00 20 20 64 61 74 61 3a 20 30     ta: 0x.  data: 0
  1020b0:	78 00 20 20 62 73 73 3a 20 30 78 00 00 00 00 00     x.  bss: 0x.....
  1020c0:	20 20 43 61 6c 6c 69 6e 67 20 74 68 65 20 73 61       Calling the sa
  1020d0:	6d 70 6c 65 20 63 6f 64 65 20 6d 6f 64 75 6c 65     mple code module
  1020e0:	20 72 65 74 75 72 6e 65 64 3a 20 00 5b 46 69 6e      returned: .[Fin
  1020f0:	69 73 68 65 64 5d 00                                ished].
